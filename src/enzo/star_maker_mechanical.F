#include "fortran.def"
#include "phys_const.def"
#include "error.def"

c=======================================================================
c////////////////////////  SUBROUTINE STAR_MAKER \\\\\\\\\\\\\\\\\\\\\\\
c
      subroutine star_maker_mechanical(nx, ny, nz,
     &                      d, dm, temp, u, v, w,
     &                      dt, r, metal, zfield1, zfield2,
     &                      dx, t, z, procnum,
     &                      dunits, x1, vunits, t1,
     &                      nmax, xstart, ystart, zstart, ibuff,
     &                      imetal, imethod, mintdyn,
     &                      odthresh, level, np,
     &                      xp, yp, zp, up, vp, wp,
     &                      mp, tdp, tcp, metalf, max_form_mass,
     &                      smLevel)

c
c  CREATES STAR PARTICLES FOR KINETIC FEEDBACK
c
c
c  INPUTS:
c
c    d     - density field
c    dm    - dark matter field
c    temp  - temperature field
c    u,v,w - velocity fields
c    cooltime - cooling time in code units
c    r     - refinement field (non-zero if zone is further refined)
c    dt    - current timestep
c    dx    - zone size (code units)
c    t     - current time
c    z     - current redshift
c    dunits,x1,vunits,t1 - factors to convert d,dx,v,t to physical units
c    nx,ny,nz - dimensions of field arrays
c    ibuff    - number of buffer zones at each end of grid
c    imethod  - Hydro method (0/1 -- PPM DE/LR, 2 - ZEUS)
c    odthresh - overdensity threshold (some number * avg. density)
c    masseff - gas-to-mass conversion efficiency ( 0<=masseff<=1 )
c    smthresh - star mass threshold (only creates stars with mass >
c        smthresh unless (random number) < starmass/smthresh )
c    mintdyn  - minimum dynamical time, in years
c    level - current level of refinement
c    procnum - processor number (for output)
c    imetalSNIa - SN Ia metallicity flag (0 - none, 1 - yes)
c
c  OUTPUTS:
c
c    np   - number of particles created
c    x/y/z start - starting position of grid origin
c    xp,yp,zp - positions of created particles
c    up,vp,wp - velocities of created particles
c    mp       - mass of new particles
c    tdp      - dynamical time of zone in which particle created
c    tcp      - creation time of particle
c    metalf   - metallicity fraction of particle
c    nmax     - particle array size specified by calling routine
c    metalfSNIa - metallicity fraction of particle (from SN Ia) ! MKRJ
c
c
c-----------------------------------------------------------------------
       implicit none
#include "fortran_types.def"
#define NO_FORTRAN_DEBUG
c-----------------------------------------------------------------------
c
c  Arguments
c
      INTG_PREC nx, ny, nz, ibuff, nmax, np, level, imetal, imethod
      INTG_PREC procnum, imetalSNIa, smLevel
      R_PREC    d(nx,ny,nz), dm(nx,ny,nz), temp(nx,ny,nz)
      R_PREC    u(nx,ny,nz), v(nx,ny,nz), w(nx,ny,nz)
      R_PREC    r(nx,ny,nz), cooltime(nx,ny,nz)
      R_PREC    metal(nx,ny,nz), zfield1(nx,ny,nz), zfield2(nx,ny,nz)
      R_PREC    dt, dx, z, exptime, max_form_mass
      R_PREC    dunits, x1, vunits, t1
      P_PREC xstart, ystart, zstart, t
      P_PREC xp(nmax), yp(nmax), zp(nmax)
      R_PREC    up(nmax), vp(nmax), wp(nmax)
      R_PREC    mp(nmax), tdp(nmax), tcp(nmax), metalf(nmax)
      R_PREC    metalSNIa(nx,ny,nz), metalfSNIa(nmax)
      R_PREC    odthresh, masseff, smthresh, mintdyn
c
c
c  Locals:
c
      INTG_PREC  i, j, k, ii
      R_PREC   div, tdyn, dtot
      R_PREC   pi, G, sndspdC
      R_PREC   isosndsp2, starmass, starfraction, bmass, jeanmass
      R_PREC   max_mass, grad_rho, tau, phi, psi, f_s, t_ff, m_units
      R_PREC   m_form, mstar
      R_PREC msolar
      parameter (pi=pi_val, G=GravConst,
     &           sndspdC=1.3095e8_RKIND,
     &           msolar=SolarMass)
c
      ii = np
      max_mass = max_form_mass * msolar /dunits/dx**3/x1**3
      m_units = dunits * (x1*dx)**3._RKIND/msolar
      exptime = 0_IKIND

!     print*,'star_maker3: imetal is:',imetal

c
c  for each zone, : "star" particle is created if answers to all the
c  following questions are affirmative:
c
c    is this the finest level of refinement ?
c    is the density greater than a critical density ?
c    is the flow convergent ?
c    is the cooling time less than a dynamical time ?
c    is the gas mass greater than the Jeans mass?
c
      do k=1+ibuff,nz-ibuff
         do j=1+ibuff,ny-ibuff
            do i=1+ibuff,nx-ibuff
c
c              1) is this finest level of refinement?
c
               if (r(i,j,k) .ne. 0._RKIND) cycle
c
c              2) is density greater than threshold?
c
                if (d(i,j,k) .lt. odthresh) cycle
c
c              3) is divergence negative?
c                 (the first calculation is face centered for ZEUS,
c                  the second is cell-centered for PPM)
c
                if (imethod .eq. 2) then
                  div = u(i+1,j  ,k  ) - u(i,j,k)
     &                + v(i  ,j+1,k  ) - v(i,j,k)
     &                + w(i  ,j  ,k+1) - w(i,j,k)
               else
                  div = u(i+1,j  ,k  ) - u(i-1,j  ,k  )
     &                + v(i  ,j+1,k  ) - v(i  ,j-1,k  )
     &                + w(i  ,j  ,k+1) - w(i  ,j  ,k-1)
               endif
               if (div .ge. 0._RKIND) goto 10
c
c              4) t_cool < t_free-fall (if T < 1.1e4 skip this check)
c
               dtot = ( d(i,j,k) + dm(i,j,k) )*dunits
               tdyn  = sqrt(3._RKIND*pi/32._RKIND/G/dtot)/t1

               if (tdyn .lt. cooltime(i,j,k) .and.
     &             temp(i,j,k) .gt. 1.1e4_RKIND) goto 10
c
c              5) is M > M_Jeans? (this definition involves only baryons under
c                 the assumption that the dark matter is stable, which
c                 implies that the dark matter velocity dispersion is >>
c                 the sound speed.  This will be true for small perturbations
c                 within large halos).
c
               bmass = d(i,j,k)*dble(dunits)*dble(x1*dx)**3 / msolar
               isosndsp2 = sndspdC * temp(i,j,k)
               jeanmass = pi/(6._RKIND*sqrt(d(i,j,k)*dble(dunits))) *
     &                    dble(pi * isosndsp2 / G)**1.5_RKIND / msolar
c
c  THIS IS COMMENTED OUT - NO JEANS MASS CRITERION IN THIS ALGORITHM!!!
c  BWO, 13 NOV 02 (fix 3 dec 02)
c
               if (jeanmass .gt. max(bmass, 1e3_RKIND)) goto 10
c
c              6) Check to see if star is above threshold (given
c                 in units of M_solar)
c
               starfraction = min(masseff*dt/tdyn, 0.9_RKIND)
               tdyn = max(tdyn, mintdyn*3.15e7_RKIND/t1)

c
c              is star mass greater than threshold, then make it.
c              if it's less than threshold, go to the next cell.
c
              grad_rho = sqrt(((d(i+1, j, k)
     &                          - d(i-1, j, k))*dunits)**2_RKIND
     &                  + ((d(i, j+1, k) -d(i, j-1, k))*dunits)**2_RKIND
     &                  + ((d(i, j, k+1) - d(i,j,k-1))*dunits)**2_RKIND)
              tau = 434.8_RKIND * d(i,j,k)*dunits
     &                    * (dx*x1 + d(i,j,k) * dunits/grad_rho)
              phi = 0.756_RKIND *
     &           (1._RKIND+ 3.1_RKIND*metal(i,j,k)
     &           /0.02_RKIND)**0.365_RKIND
              psi = (0.6_RKIND * tau
     &               * (0.01+metal(i,j,k)/0.02_RKIND))
     &               / (log(1_RKIND+0.06_RKIND
     &               * phi + 0.01_RKIND
     &               * (phi)**2_RKIND))
              f_s = 1._RKIND - 3._RKIND/(1._RKIND+ 4._RKIND*psi)
              if (f_s .le. 0._RKIND) goto 10
              if (f_s .gt. 1._RKIND) f_s = 1._RKIND
              t_ff = sqrt(3._RKIND*dble(pi / (32._RKIND * G * d(i,j,k)*dunits)))/t1
c
c              Create a star particle
c
              m_form = max(1e3_RKIND/m_units,
     &                    min(f_s * d(i,j,k)/t_ff*dt, max_mass))
               ! cant make a star without the mass in the cell...
              if (m_form .gt. d(i,j,k)) cycle
              ii = ii + 1
              mp(ii)  =  m_form
              ! negative cells are very bad, so double check
              if (mp(ii) .gt. d(i,j,k)) then
                write(6,*) "Fatal Error: Mass of star > Mass of cell"
                write(6,*) "Mcell = ", d(i,j,k) * m_units
                write(6,*) "Mptcl = ", mp(ii) * m_units
                write(6,*) "F_s =", f_s
                write(6,*) "t_ff =", t_ff*t1
                write(6,*) "tried mass = ", f_s * d(i,j,k)/t_ff * m_units
                ERROR_MESSAGE
              endif
        mstar = m_form*m_units
#ifdef FORTRAN_DEBUG
              write(6,*) "created star ptcl! MP =",mstar,
     &                     'overdensity = ', d(i,j,k), 'f_s = ',f_s,
     &                     'level =', level
#endif
              tcp(ii) = t
              tdp(ii) = tdyn
c              If discrete explosions are used, then use tdp as
c              a flag indicating whether the particle has done
c              feedback rather than dynamical time field
              if (exptime .eq. 0_IKIND) then
                tdp(ii) = 0._RKIND
              endif
              xp(ii) = xstart + (REAL(i,RKIND)-0.5_RKIND)*dx
              yp(ii) = ystart + (REAL(j,RKIND)-0.5_RKIND)*dx
              zp(ii) = zstart + (REAL(k,RKIND)-0.5_RKIND)*dx
c
c              Star velocities averaged over multiple cells to
c              avoid "runaway star particle" phenomenon
c              imethod = 2 is zeus, otherwise PPM

              if (imethod .eq. 2) then
                up(ii) = 0.5_RKIND*(u(i,j,k)+u(i+1,j,k))
                vp(ii) = 0.5_RKIND*(v(i,j,k)+v(i,j+1,k))
                wp(ii) = 0.5_RKIND*(w(i,j,k)+w(i,j,k+1))
              else
                up(ii) = u(i,j,k)
                vp(ii) = v(i,j,k)
                wp(ii) = w(i,j,k)
              endif
c
c              Set the particle metal fraction
c
              if (imetal .eq. 1) then
                metalf(ii) = metal(i,j,k)    ! in here metal is a fraction
              else
                metalf(ii) = 0._RKIND
              endif
c
c              MKRJ 2/20/08 Do the same for particle metal fraction from SN Ia
c
              if (imetalSNIa .eq. 1) then
                metalfSNIa(ii) = metalSNIa(i,j,k)    ! in here metal is a fraction
              endif
c
c              Remove mass from grid
c
              d(i,j,k) = d(i,j,k) - mp(ii)
c
c
 1000          format(i5,1x,6(1pe10.3,1x))
c
c              Do not generate more star particles than available
c
              if (ii .eq. nmax) goto 20

 10          continue

            enddo
         enddo
      enddo
 20   continue
c
      if (ii .ge. nmax) then
         write(6,*) 'star_maker_mechanical: reached max new particle count'
         ERROR_MESSAGE
      endif
      np = ii
c
#ifdef FORTRAN_DEBUG
      if (np .ne. 0) then
         write(6,*) 'Stars created: number,time,level: ', np, t, level
      endif
#endif
c
      return
      end
c
c
c
c===================================================================================
c////////////////////// SUBROUTINE STAR FEEDBACK MECHANICAL \\\\\\\\\\\\\\\\\\\\\\\\
c
c
c    Routine to handle mechanical feedback from stars.  Creation is handled as
c    star_maker3mom, i.e., Cen & Ostriker stochastic formation but with stars given
c    the bulk velocity of progenitor gas.
c
c
c    If SingleSN = 1, Supernova are handled discretely, drawing the probability of a SN II, Ia.
c    Stars stay active indefinitely (until a lower mass limit to prevent
c    negative mass stars), feeding back winds based on the age of the
c    particle:
c    young particles have strong & fast winds from OB stars, old particles
c    have slow winds from AGB.
c
c     This was imported from a very early version of enzo, and is missing some feed-
c     back types: SNIa, cosmic rays, etc.
c=======================================================================
c/////////////////////  SUBROUTINE STAR_FEEDBACK \\\\\\\\\\\\\\\\\\\\\\\
c
      subroutine star_feedback_mechanical(nx, ny, nz,
     &               mu_field, d, dm, te, ge, u, v, w,
     &               metal, zfield1, zfield2,
     &               idual, imetal, imulti_metals, imethod,
     &               dt, r, dx, t, z, h, omegaM, omegaL,
     &               dunits, x1, vunits, t1,
     &               npart, xstart, ystart, zstart, ibuff,
     &               xp, yp, zp, up, vp, wp,
     &               mp, tdp, tcp, metalf, type,
     &               star_winds, single_sn, max_star_mass,
     &               odthresh, deposit_unresolved, one_event,
     &               analytic_shell_mass)

c
c  RELEASES "STAR" PARTICLE ENERGY, MASS AND METALS
c
c  written by: Azton Wells
c  date:      Jan 2019
c
c
c  INPUTS:
c
c    d     - density field
c    dm    - dark matter field
c    te,ge - total energy and gas energy fields
c    u,v,w - velocity fields
c    metal - metallicity density field
c    r     - refinement field (0 if zone is further refined)
c    dt    - current timestep
c    dx    - zone size (code units)
c    t     - current time
c    z     - current redshift
c    h     - hubble constant at z=0 km/s/mpc
c    O_m   - omega_matter at z=0
c    O_l   - omega_lambda at z=0
c    dunits,x1,vunits,t1 - factors to convert d,dx,v,t to physical units
c    nx,ny,nz - dimensions of field arrays
c    ibuff    - number of buffer zones at each end of grid
c    idual    - dual energy flag
c    imetal   - metallicity flag (0 - none, 1 - yes)
c    imulti_metals - flag to use multi metals zfield 1 and 2
c    imethod  - hydro method (0 - PPMDE, 1 - PPMLR, 2 - ZEUS)
c    distrad  - feedback distribution radius in cells
c    diststep - distance in walking steps to deposit feedback
c    distcells - total number of cells over which to distribute feedback
c
c    x/y/z start - starting position of grid origin
c    xp,yp,zp - positions of created particles
c    up,vp,wp - velocities of created particles
c    mp       - mass of new particles
c    tdp      - dynamical time of zone in which particle created or
c               if exptime >= 0, a flag for whether the discrete
c               explosion has occurred
c    tcp      - creation time of particle (-1 if not a star particle)
c    metalf   - star particle metal fraction
c    npart    - particle array size specified by calling routine
c    yield    - fraction of stellar mass that is converted to metals
c    type     - particle type
c    star_winds - flag to use continuous winds (stellar mass loss)
c    discrete_sn - flag to use discrete sn or continuous injection
c
c  OUTPUTS:
c    d,u,v,w,ge,e - modified field
c    justburn     - time-weighted mass of star formation (code units)
c
c
c-----------------------------------------------------------------------
       implicit none
#include "fortran_types.def"
#include "phys_const.def"
c-----------------------------------------------------------------------
#define NO_FORTRAN_DEBUG
c
c  Arguments
c
      INTG_PREC nx, ny, nz, ibuff, npart, idual, imetal,
     &      imulti_metals, imethod, single_sn,
     &      distrad, diststep, distcells, star_winds,
     &      deposit_unresolved, analytic_shell_mass
      R_PREC    d(nx,ny,nz), dm(nx,ny,nz), te(nx,ny,nz)
      R_PREC    u(nx,ny,nz), v(nx,ny,nz), w(nx,ny,nz)
      R_PREC    r(nx,ny,nz), ge(nx,ny,nz)
      R_PREC    metal(nx,ny,nz), mu_field(nx,ny,nz)
      R_PREC    zfield1(nx,ny,nz), zfield2(nx,ny,nz)
      R_PREC    dt, dx, z, h, omegaM, omegaL, max_star_mass
      R_PREC    dunits, x1, vunits, t1, justburn
      R_PREC xstart, ystart, zstart, t
      R_PREC xp(npart), yp(npart), zp(npart)
      R_PREC    up(npart), vp(npart), wp(npart)
      R_PREC    mp(npart), tdp(npart), tcp(npart), metalf(npart)
      INTG_PREC type(npart)
c
c
c  Locals
c
c
c    (msolar_e51 is one solar rest mass energy divided by 10^51 erg)
c
      INTG_PREC n, ic, jc, kc, ip, jp, kp,
     &            i, j, k, a, ax, p, one_event, continual_formation,
     &            n_events, np
      INTG_PREC n_sn_ii, n_sn_ia, iface, jface, kface
      R_PREC   zcell, f_factor,m_cell,
     &         odthresh, div, grad_rho, dcell,
     &         tau_cell, phi_cell, psi_cell, f_shielded,
     &         t_ff, m_form, modxba, num, denom, rmp, rpm,
     &         sum_weights, sum_factor, wind_factor, psi_k, temp,
     &         hcell, metal_ejecta
      R_PREC R_ii, R_ia, m_eject, m_winds, wind_metal, snii_metals,
     &          snia_metals, e_sn, p_ej, v_wind, ke_post,
     &          e_wind, P_ii, P_ia, adotx, m_units,
     &          m_deposited, e_deposited, p_units, e_units
      R_PREC mag_xba(3,3,3), weights(3,3,3)
      R_PREC xba(3,3,3,3), p_deposited(3), ahats(3,3,3,3)
      R_PREC nbor(3,3,3,3), weightsFinal(3,3,3,3)
      R_PREC dxf, dyf, dzf, dxc, dyc, dzc, xfc, yfc, zfc,
     &     xfcshift,yfcshift,zfcshift, xpos, ypos, zpos,
     &     xface, yface, zface, face_shift, e_diff
      R_PREC Zsol, energy_51, eunits, e_const, ergs_51, fbuff, pi
      R_PREC msolar, msolar_e51, mH, g, mstar, age, max_mass, track_sn
      R_PREC ke_pre(4,4,4)
      R_PREC tempx, tempy, tempz
      R_PREC random
c
c-----------------------------------------------------------------------
c
c     Loop over particles
c
      if (imethod .ne. 0) then
        write (6,*) 'mechanical feedback only',
     &    ' works with PPM hydro solver! method= ',imethod
        goto 10
      endif

      track_sn = 1_IKIND ! tracks supernovae energy in the tdp property
      n_events = 0_IKIND ! tracking number of SNe on this grid
      e_deposited = 0._RKIND ! tracking total amount of energy deposited this grid
      msolar = SolarMass ! grams per m_sol
      pi = pi_val
      g = GravConst
      m_units = dunits * (x1)**3*dx**3 / msolar     ! Msun
      e_units = dunits * x1**5*dx**3  /t1**2 ! ergs
      p_units = sqrt(m_units*msolar*e_units)/1e5/msolar ! Msun*km/s
      max_mass = max_star_mass / m_units
      np = 0_IKIND
c
c   Loop over particles
c
      do n=1_IKIND, npart
        if (tcp(n) .gt. 0._RKIND .and.
     &          mp(n) .gt. 20.0/m_units .and.
     &          type(n) .eq. 2_IKIND) then
            np = np + 1_IKIND
            if (tdp(n) .gt. 1e5_RKIND) tdp(n) = tdp(n) / 1.0e51_RKIND 
c
c   center of feedback zone
c
            ip = int((xp(n) - xstart)/dx) + 1_IKIND
            jp = int((yp(n) - ystart)/dx) + 1_IKIND
            kp = int((zp(n) - zstart)/dx) + 1_IKIND

            if (xp(n) .lt. xstart .or. xp(n) .gt. xstart+dx*nx .or.
     &          yp(n) .lt. ystart .or. yp(n) .gt. ystart+dx*ny .or.
     &          zp(n) .lt. zstart .or. zp(n) .gt. zstart+dx*nz) then
c               write(6,*) 'warning: starOOG ',
c     &              tdp(n), n, xp(n),yp(n),zp(n), 
c     &              xstart, ystart, zstart, 
c     &              ip,jp,kp,
c     &              up(n), vp(n), wp(n),
c     &              mp(n), tcp(n), metalf(n)
               goto 100
            endif
c
c	Set center of feedback zone
c
            xfc = xp(n)
            yfc = yp(n)
            zfc = zp(n)
            fbuff = ibuff + 2._RKIND
            mstar = mp(n) * m_units
c
c         check bounds - if star particle is near grid edge
c         then shift center of feedback region
c
            if (xfc .lt. xstart+fbuff*dx .or.
     &          xfc .gt. xstart+dx*nx-fbuff*dx .or.
     &          yfc .lt. ystart+fbuff*dx .or.
     &          yfc .gt. ystart+dx*ny-fbuff*dx .or.
     &          zfc .lt. zstart+fbuff*dx .or.
     &          zfc .gt. zstart+dx*nz-fbuff*dx) then
#ifdef FORTRAN_DEBUG
               write(6,*) 'warning1: star feedback zone shifted',
     &              xfc,yfc,zfc, xstart, ystart, zstart,fbuff
#endif
c
	       xfcshift = xfc
	       yfcshift = yfc
	       zfcshift	= zfc
c
	       xfc = max(xfc,xstart+fbuff*dx)
	       yfc = max(yfc,ystart+fbuff*dx)
	       zfc = max(zfc,zstart+fbuff*dx)
c
	       xfc = min(xfc,xstart+dx*nx-fbuff*dx)
	       yfc = min(yfc,ystart+dx*ny-fbuff*dx)
	       zfc = min(zfc,zstart+dx*nz-fbuff*dx)
c
	       xfcshift = xfcshift - xfc
	       yfcshift = yfcshift - yfc
	       zfcshift	= zfcshift - zfc
c
#ifdef FORTRAN_DEBUG
	       write(6,*) 'warning2: star feedback zone shifted',
     &              xfc,yfc,zfc,dx,xfcshift,yfcshift,zfcshift,
     &		    nx, ny,nz
#endif
            endif
            xpos = (xfc - xstart)/dx - 0.5_RKIND
            ypos = (yfc - ystart)/dx - 0.5_RKIND
            zpos = (zfc - zstart)/dx - 0.5_RKIND
            ic = int(xpos + 0.5_RKIND)
            jc = int(ypos + 0.5_RKIND)
            kc = int(zpos + 0.5_RKIND)

c
c    7/?  Transform to comoving coords
c
c
            call mech_momentum(u,v,w,d,metal,up(n), vp(n), wp(n),
     &                        nx, ny, nz, ic, jc, kc,
     &                        iface, jface, kface,
     &                        imethod, imetal, +1_IKIND)
c
c
c
            face_shift = 0._RKIND
            if (imethod .eq. 2) face_shift = 0.5_RKIND
            dxc = real(ic) + 0.5_RKIND - xpos
            dyc = real(jc) + 0.5_RKIND - ypos
            dzc = real(kc) + 0.5_RKIND - zpos
c
c         Compute index of the first cell to add momentum,
c             accounting for possible face-centering
c
            xface = (xfc - xstart)/dx - 0.5_RKIND - face_shift
            yface = (yfc - ystart)/dx - 0.5_RKIND - face_shift
            zface = (zfc - zstart)/dx - 0.5_RKIND - face_shift
c
            iface = int(xface + 0.5_RKIND)
            jface = int(yface + 0.5_RKIND)
            kface = int(zface + 0.5_RKIND)
c
            dxf = real(iface) + 0.5_RKIND - xface
            dyf = real(jface) + 0.5_RKIND - yface
            dzf = real(kface) + 0.5_RKIND - zface

c    1/?  Check for continual formation:
c              a.)  require gas still be dense enough for
c                   self shielding using local Sobolev approximation
c                   and that overdensity is > n.
c
c              b.)  make sure divergence of gas flow is still negative
c              c.)  need M_jeans < m_crit
c
            m_form = 0._RKIND
            zcell = metal(ic, jc, kc)
            dcell = d(ic,jc,kc) * dunits
	          m_cell = d(ic,jc,kc) * m_units
            m_deposited = 0._RKIND
#ifdef FORTRAN_DEBUG
            do i = 1_IKIND, 3_IKIND
              p_deposited(i) = 0._RKIND
            enddo
#endif
c
c           a.) divergence of the gas
c
            if (mp(n) .gt. max_mass) goto 999
            if (imethod .eq. 2) then
                  div = u(ic+1,jc  ,kc  ) - u(ic,jc,kc)
     &                + v(ic  ,jc+1,kc  ) - v(ic,jc,kc)
     &                + w(ic  ,jc  ,kc+1) - w(ic,jc,kc)
            else
                  div = u(ic+1,jc  ,kc  ) - u(ic-1,jc  ,kc  )
     &                + v(ic  ,jc+1,kc  ) - v(ic  ,jc-1,kc  )
     &                + w(ic  ,jc  ,kc+1) - w(ic  ,jc  ,kc-1)
            endif

c
c           c.) calculate shielded fraction via Krumholz & Gnedin 2011
c
            hcell = dx*x1
            grad_rho = sqrt((d(ic+1, jc, kc) - d(ic-1, jc, kc))**2._RKIND*dunits
     &                  + (d(ic, jc+1, kc) -d(ic, jc-1, kc))**2._RKIND*dunits
     &                  + (d(ic, jc, kc+1) - d(ic,jc,kc-1))**2._RKIND*dunits)
            tau_cell = 434.8_RKIND * dcell * (dx *x1+ dcell/(grad_rho))
            phi_cell = 0.756_RKIND * (1+ 3.1_RKIND*zcell/0.02_RKIND)**0.365_RKIND
            psi_cell = (0.6_RKIND * tau_cell * (0.01+zcell/0.02_RKIND))
     &               / (log(1_RKIND+0.06_RKIND * phi_cell + 0.01_RKIND
     &               * (phi_cell)**2_RKIND))
            f_shielded = 1_RKIND - 3_RKIND/(1_RKIND+ 4_RKIND*psi_cell)
            if (div .le. 0._RKIND .and. d(ic,jc,kc) .ge. odthresh
     &        .and. f_shielded .gt. 0._RKIND
     &        .and. mp(n) .le. max_mass) then
              t_ff = sqrt(3._RKIND*pi / (32._RKIND * g * dcell))/t1
#ifdef FORTRAN_DEBUG
              write(0,*) 'f, tff, d, dt: ',f_shielded,
     &              t_ff*t1, m_cell, dt
#endif
              m_form = dt * f_shielded
     &                  *d(ic,jc,kc)*m_units / (t_ff)
            endif
c           add mass to star particle
#ifdef FORTRAN_DEBUG
            write(6,*) 'mass formed: ', m_form/m_units
#endif
           m_form = m_form / m_units
            if (m_form .gt. 0._RKIND .and. mp(n)+m_form .lt. max_mass
     &              .and. mp(n) .lt. max_mass) then
              mp(n) = mp(n) + m_form
            else
              if (m_form + mp(n) .gt. max_mass) then
                m_form = max_mass - mp(n)
                mp(n) = max_mass
              endif
            endif
#ifdef FORTRAN_DEBUG
            write(6,*) 'mass added to ptcl: ', m_form*m_units
#endif

c
c           remove mass from the grid cell.
c
            d(ic, jc, kc) = d(ic, jc, kc) - m_form
c
c
c    2/?  Construct the 3x3 mask to distribute feedback.
c                 make arrays of neighbor positions (x,y,z),
c                 weights.  The weights estimate the amount of
c                 feedback that will be deposited to cell 'b'
c                 and is calculated as in Hopkins, 2017
c
c
c           get a list of positions of neighbor "particles"
c    __ Construct Neighbor particle mask that acts as coupled particles for deposition
c

 999        mstar = mp(n) * m_units
            do k = 1_IKIND, 3_IKIND
              do j = 1_IKIND, 3_IKIND
                do i = 1_IKIND, 3_IKIND
                  nbor(i,j,k, 1) = xp(n) + dx * REAL(i - 2)
                  nbor(i,j,k, 2) = yp(n) + dx * REAL(j - 2)
                  nbor(i,j,k, 3) = zp(n) + dx * REAL(k - 2)
                  xba(i,j,k, 1) = dx * (REAL(i - 2))
                  xba(i,j,k, 2) = dx * (REAL(j - 2))
                  xba(i,j,k, 3) = dx * (REAL(k - 2))
                  mag_xba(i,j,k) = 0._RKIND
                  ke_pre(i,j,k) = 0._RKIND !0.5 * (u(ic+i-2,jc+j-2,kc+k-2)**2
    !  &                                  + v(ic+i-2,jc+j-2,kc+k-2)**2
    !  &                                  + w(ic+i-2,jc+j-2,kc+k-2)**2)
    !  &                                  / d(ic+i-2,jc+j-2,kc+k-2)
                enddo
              enddo
            enddo
c
c
c    __ Construct Wieghts vector.  Each entry is the fraction of energy that goes into that
c               coupling particle
c
c           __ Area vector for A.dot(xba)
c                 generate vector that has scalar xba^2
            do k = 1_IKIND, 3_IKIND
              do j = 1_IKIND, 3_IKIND
                do i = 1_IKIND, 3_IKIND
                  do ax = 1_IKIND, 3_IKIND
                    mag_xba(i,j,k) = mag_xba(i,j,k)
     &                        + xba(i,j,k,ax)*xba(i,j,k,ax)
                  enddo
                enddo
              enddo
            enddo
            do k = 1_IKIND, 3_IKIND
              do j = 1_IKIND, 3_IKIND
                do i = 1_IKIND, 3_IKIND
c
c
c         Make ahat vector; entries point from xp to fb particle
c             with magnitude ~ area of face between particles, which is
c             approximately 4 pi/26 for this symmetric distribution
c
                  do ax = 1_IKIND, 3_IKIND
                    if (mag_xba(i,j,k) .eq. 0._RKIND) then
                      ahats(i,j,k,ax) = 0._RKIND
                    else
                      ahats(i,j,k,ax) = 4._RKIND*pi/26._RKIND
     &                             * xba(i,j,k,ax)/sqrt(mag_xba(i,j,k))
                    endif
                  enddo
                enddo
              enddo
            enddo
c
c
c    __ Make array of scalar weights that determine fraction of
c         feedback that goes into the neighbor particles.
c
            sum_weights= 0.0_RKIND
            do k = 1_IKIND, 3_IKIND
              do j = 1_IKIND, 3_IKIND
                do i = 1_IKIND, 3_IKIND
                  if (i .eq. 2_IKIND
     &                  .and. j .eq. 2_IKIND
     &                  .and. k .eq. 2_IKIND) then
                    weights(i,j,k) = 0._RKIND
                  else
                    temp = 0._RKIND
                    do ax = 1_IKIND, 3_IKIND
                      temp = temp+ahats(i,j,k,ax)*
     &                       xba(i,j,k,ax)
                    enddo
                    if (mag_xba(i,j,k) .eq. 0._RKIND) then
                      temp = 0._RKIND
                      weights(i,j,k) = 0._RKIND
                    else
                      temp = temp / sqrt(mag_xba(i,j,k))
                      weights(i,j,k) = 0.5_RKIND*(1_RKIND-1_RKIND/(sqrt(1._RKIND
     &                            + temp/(pi*mag_xba(i,j,k)))))
                    endif
                    sum_weights = sum_weights + weights(i,j,k)
                  endif
                enddo
              enddo
            enddo
            do k= 1_IKIND, 3_IKIND
              do j= 1_IKIND, 3_IKIND
                do i = 1_IKIND,3_IKIND
                  weights(i,j,k) = weights(i,j,k) / sum_weights
                  if (isnan(weights(i,j,k))) write(*,*) 'nan weight: ', i,j,k,
     &                    "sum_weights =", sum_weights
                enddo
              enddo
            enddo

            do k= 1_IKIND, 3_IKIND
              do j= 1_IKIND, 3_IKIND
                do i = 1_IKIND,3_IKIND
                  do ax = 1_IKIND, 3_IKIND
                    if (i == 2_IKIND .and. j == 2_IKIND
     &                .and. k == 2_IKIND) then
                      weightsFinal(i,j,k,ax) = 0.0_RKIND
                      continue
                    else
                      weightsFinal(i,j,k,ax) =
     &                      xba(i,j,k, ax)/sqrt(mag_xba(i,j,k))
     &                            *weights(i,j,k)
                    endif
                  enddo
                enddo
              enddo
            enddo
c
c               Although Hopkins 2017 has tensor corrections using plus/minus
c                 vectors, this formulation does not require it, since
c                 the coupled particles are symmetric about the
c                 star particle.
c
c
c    3/?  if age is low enough, check for supernova
c              rates are per solar mass per Myr

            R_ii = 0._RKIND
            R_ia = 0._RKIND
            m_eject = 0._RKIND
            m_winds=0._RKIND
            e_wind=0._RKIND
            wind_metal=0._RKIND
            p_ej=0._RKIND
            wind_factor = 0._RKIND
            age = (t-tcp(n))*t1/3.14e13_RKIND
            if (age .lt. 0._RKIND) goto 100
            if (single_sn .eq. 1_IKIND) then
              if (age .lt. 37.53_RKIND) then
                R_ia = 0._RKIND
                if (age .lt. 10.37_RKIND
     &               .and. age .gt. 3.401_RKIND) then
                  R_ii = 0.0005408_RKIND
                endif
                if (age .gt. 10.37_RKIND) then
                         R_ii = 0.0002516_RKIND
                endif
              endif
              if (age .ge. 37.53_RKIND) then
                R_ia = 5.3e-8_RKIND + 1.6e-5_RKIND
     &                   * exp(-1.0*((age-50._RKIND)/10._RKIND)**2._RKIND/2._RKIND)
              endif
              if (age .lt. 3.401_RKIND) then
                    R_ia = 0._RKIND
              endif
c
c    4/?  Draw from random to see if SN happen or not this timestep
c
            call random_number(random)
            n_sn_ii = 0._RKIND
            n_sn_ia = 0._RKIND
c            if (one_event .gt. 0._RKIND) then
c              if (tdp(n)/1e51_RKIND .gt. one_event) goto 110
c              if (tdp(n)/1e51_RKIND .le. one_event) then
!                 n_sn_ii = 1._RKIND
! c               tdp(n) = tdp(n) + 1._RKIND
c                 goto 130
!               endif
c            endif
            P_ii = mstar * R_ii*dt*t1/3.14e13_RKIND
            if (P_ii .gt. 1._RKIND) then
              write(6,*) 'P_ii: ', P_ii
              write(6,*) 'MP: ',mp(n)*m_units, 'dt: ', dt, 'T1: ',t1
              write(6,*) 'P_ii > 1.0!!'
              write(6,*)
     &          'Need to reduce timesteps or reduce particle mass!!'
c
c       Allow a SNe or two to go off with no restrictions
c         but after that, require that p_ii < 1 s.t. only 1 sne per timestep!
c
              if (t-tcp(n)*t1/3.14e13_RKIND .gt. 4.0) then
                write(0,*) 'Too old and too high P_ii!!! Exiting!!!'
                ERROR_MESSAGE
              endif
            endif
            if (random .le. P_ii
     &                .and. mstar .gt. 10.5) then
               n_sn_ii = 1._RKIND
            else
               n_sn_ii = 0._RKIND
            endif
            if (age .ge. 37.53_RKIND) then
              call random_number(random)
              if (random .le. mstar * R_ia * dt * t1/3.14e13_RKIND) then
                n_sn_ia = 1._RKIND !anint(mp(n) * R_ia * dt * t1/3.14e13_RKIND)
              else
                n_sn_ia = 0._RKIND
              endif
            else
              n_sn_ia = 0._RKIND
            endif
 130        if (n_sn_ia .eq. 0._RKIND
     &              .and. n_sn_ii .eq. 0._RKIND) then
c              write(6,*) 'no supernova this step'
!              write(0,*) 'P_ii=',P_ii, 'random = ', random
              goto 110
#ifdef FORTRAN_DEBUG
              else
                write(0,*) 'SUPERNOVA!!',n, n_sn_ii, n_sn_ia,
     &            age
#endif
            endif
c
c    5/?  Calculate mass ejected, metal ejected and energy from sn
c
            n_events = n_events + n_sn_ia + n_sn_ii
!            if (track_sn .eq. 1_IKIND) tdp(n) = tdp(n) + 1._RKIND


c
c         i.) mass in Msun of metal from type II
            snii_metals = n_sn_ii * (1.91_RKIND
     &                   + 0.0479*MAX(zcell/0.02_RKIND, 1.65_RKIND))
            m_eject = m_eject + n_sn_ii * 10.5_RKIND
c         ii.) mass in Msun of metals from type Ia
            snia_metals = n_sn_ia * 1.4_RKIND
            m_eject = m_eject + n_sn_ia * 1.4_RKIND
            if (m_eject .ge. mp(n)*m_units) then
              m_eject = 0._RKIND
              goto 170
            endif
c         iii.) energy in supernova (simple assuming 1e51 ergs/sn)
            e_sn = 1.0e51_RKIND * (n_sn_ia + n_sn_ii) / e_units
c
c    6/? send to add_feedback subroutine with supernova feedback values
c
            m_eject = m_eject/m_units
            metal_ejecta = (snia_metals + snii_metals)
     &                    /m_units
            p_ej = sqrt(2._RKIND * e_sn
     &              * m_eject)
#ifdef FORTRAN_DEBUG
            write(0,*) 'SN ejected mass: ',m_eject*m_units
#endif

            call mech_add_feedback (nbor, weights,weightsFinal,xba,
     &                        u, v, w,mu_field,d,ge,te,metal,
     &                        nx,ny,nz,ic,jc,kc,iface,
     &                        jface,kface,dxf,dyf,
     &                        dzf,dxc,dyc,dzc,imethod,
     &                        imetal, idual, m_eject,
     &                        metal_ejecta, p_ej, e_sn,
     &                        m_deposited, e_deposited, p_deposited,
     &                        p_units,zcell, e_units,
     &                        m_units,dunits,dx, 0_IKIND,x1,
     &                        deposit_unresolved, odthresh,
     &                        analytic_shell_mass, ke_pre)
            endif
c
c    6/?  Calculate mass loss from winds, if applicable
c
c         a.) Mass loss; msun / Gyr
c
c        write(6,*) 'calculating winds'

 110        if (star_winds .eq. 1_IKIND .and.
     &              mstar .gt. 20._RKIND) then
              if (age < 1._RKIND) then
                    wind_factor = 4.763_RKIND
     &                    * min((0.01_RKIND + zcell/0.02_RKIND), 1.0)
     &                           * age
              endif
              if (age > 1._RKIND .and. age < 3.5_RKIND) then
                    wind_factor = 4.763_RKIND *
     &                    min((0.01_RKIND + zcell/0.02_RKIND), 1.0)
     &                            *(age)
     &                           **(1.45_RKIND + 0.08_RKIND
     &                           * min(log(zcell/0.02_RKIND), 1.0))
              endif
              if (age > 3.5_RKIND .and. age < 100_RKIND) then
                    wind_factor =
     &                  29.4 * (age / 3.5_RKIND)**(-3.25_RKIND)
     &                           + 0.0042_RKIND
              endif
              if (age > 100._RKIND) then
                    wind_factor = 0.42_RKIND * (age / 1000._RKIND)**(-1.1_RKIND)
     &                           / (19.81_RKIND/log(age))
              endif
c
                m_winds = mp(n)*m_units
     &                    * wind_factor * dt * t1 / 3.14e16_RKIND
                if (m_winds .gt. mp(n)*m_units) then
                  m_winds = 0.054_RKIND*mp(n)*m_units
                  write(6,*) 'M_winds too large'
                endif
                m_winds = m_winds/m_units
                if (m_winds*m_units .lt. 1) goto 170
                m_eject = m_winds + m_eject
c         b.) winds metals
                wind_metal = (0.0278_RKIND + 0.0041_RKIND
     &          * min(max(zcell/0.02_RKIND, 1.65_RKIND), 5.0)) * m_winds
c
c         c.) energy in winds
c              i.) l_kinetic
              if (age .lt. 100_RKIND) then
                  psi_k = 5.94e4_RKIND
     &                  / (1._RKIND+ age/2.5_RKIND)**(1.4_RKIND)
     &                  + (age/50._RKIND)**5._RKIND + 4.83_RKIND
              endif
              if (age .ge. 100_RKIND) then
                  psi_k = 4.83_RKIND
              endif
c              ii.) v_wind
c
c              v_wind = sqrt(2_RKIND * psi_k * 10**12_RKIND)
              e_wind = psi_k * 1e12_RKIND * m_winds * m_units
     &                /e_units
              p_ej = sqrt(2._RKIND * e_wind / m_winds)

              if (e_wind * e_units .gt. 1e51_RKIND) then
                write(0,*) "problematic wind energy: e_wind = ", e_wind*e_units
                ERROR_MESSAGE
              endif
              call mech_add_feedback(nbor, weights,weightsFinal,xba,
     &                        u, v, w,mu_field,d,ge,te,metal,
     &                        nx,ny,nz,ic,jc,kc,iface,
     &                        jface,kface,dxf,dyf,
     &                        dzf,dxc,dyc,dzc,imethod,
     &                        imetal, idual, m_winds,
     &                        wind_metal, p_ej, e_wind,
     &                        m_deposited, e_deposited, p_deposited,
     &                        p_units,zcell, e_units,
     &                        m_units,dunits,dx, 1_IKIND, x1,
     &                        deposit_unresolved, odthresh,
     &                        analytic_shell_mass, ke_pre)
            endif ! star_winds == 1
c    remove mass from particle
c#ifdef FORTRAN_DEBUG
170           if (mp(n)*m_units .lt. 100._RKIND) then
                  write(6,*) 'total mass loss: ', m_eject * m_units,
     &                    'particle mass = ', mp(n) * m_units
              endif
c#endif
c
c       One last check; if the mass of particle is negative, set to ~0
c
            mp(n) = mp(n) - m_eject
              if (mp(n) .lt. 0._RKIND) mp(n) = 1._RKIND
c
c     If any events happened, need to deposit the kinetic energy change
c         into the te field (if using dual energy)
c
          if (n_sn_ii .gt. 0_IKIND .or. n_sn_ia .gt. 0_IKIND) then
            do k = -1_IKIND, 2_IKIND
              do j = -1_IKIND, 2_IKIND
                do i = -1_IKIND, 2_IKIND
                  if (idual .eq. 1) te(ic+i, jc+j, kc+k) =
     &                    te(ic+i,jc+j,kc+k)
     &                    +(ke_pre(i+2,j+2,k+2)/e_units)/d(ic+i,jc+j,kc+k)
                  if (tdp(n) .gt. 1e5_RKIND) tdp(n) = tdp(n) / 1.0e51_RKIND
                  if (track_sn .eq. 1) tdp(n) = tdp(n)
     &                    +(ke_pre(i+2,j+2,k+2)/1.0e51_RKIND)
                  e_deposited = e_deposited +
     &                      ke_pre(i+2,j+2,k+2)
c                  write(0,*) 'depositing e = ', ke_pre(i+2, j+2, k+2)
                enddo
              enddo
            enddo
          endif
            call mech_momentum(u,v,w,d,metal, up(n), vp(n), wp(n),
     &                  nx, ny, nz, ic, jc, kc,
     &                  iface, jface, kface,
     &                  imethod, imetal, -1_IKIND)
c
c       Error checking:
c
! #ifdef FORTRAN_DEBUG
c          if (mp(n)*m_units .lt. 1000._RKIND) 
c     &         write(0,*) 'mp post: ', mp(n)*m_units
!           write(0,*) 'e_deposited/e_ejected: ',
!      &                  e_deposited/((e_sn+e_wind)*e_units)
!           write(0,*) '|P|: ', (p_deposited(1) + p_deposited(2)
!      &                + p_deposited(3))*p_units
!           write(0,*) 'Metal deposited/ejected: ',
!      &          m_deposited/(metal_ejecta+wind_metal)
!           write(0,*) "mass of host cell: ", d(ic,jc,kc)/m_units
! #endif
          endif ! star particle calculation
 100    continue
        enddo    ! end loop over particles
#ifdef FORTRAN_DEBUG

          if (n_events .gt. 0) then
          write(0,*) "From NP = ", np, "Number of SNe = ", n_events,
     &               "depositing E = ", e_deposited
        endif
#endif
 10   return
      end
c
c
c=================================================================================
c                 Adding Feedback
c=================================================================================
c
cc     Compute and deposit momentum.  This follows the
c              mechanical feedback methods present in Hopkins 2017.
c              Each neighbor cell is taken as a point of gas at cell
c              center to calculate the coupling from stellar feedback.
c              Takes in a list of "particle" positions creating a 3x3 cloud
c              along with weight vectors for each "particle".
c              Each cloud particle is then distributed to the mesh using
c              cloud-in-cell
c
c       nbor - position of neighbor cloud particles that have coupled to feedback
c       weightsFinal - array of weights determining coupling to neighbor particles
c       m_eject - mass of ejecta
c       e_sn    - energy of ejecta
c       p_ej    - total ejected momenta e_sn= p_ej^2/2 m_eject
c       d, metal, te, ge - density, metal, total energy and thermal energy fields
c       nx, ny, nz -number of entries in d, metal, te, ge
c       x1, t1, dunits - conversion of distance, time, density to physical units
c       imetal - metallicity field flag
c       mcell - mass of the feedback particle is ~mass of cell
c       mdep, edep, pdep - running sum of deposited momenta, energy and mass
      subroutine mech_add_feedback(nbor, weights, weightsFinal, xba,
     &                        pu, pv, pw,mu,
     &                        d, ge, te, metal, nx, ny, nz,
     &                        ic, jc, kc, iface, jface, kface,
     &                        dxf, dyf, dzf, dxc, dyc, dzc,
     &                        imethod, imetal, idual,
     &                        m_eject, metal_ejecta, p_ej, e_sn,
     &                        m_deposited, e_deposited,p_deposited,
     &                        p_units,zcell,e_units,
     &                        m_units,d_units,dx, winds, xunits,
     &                        deposit_unresolved, odthresh,
     &                        analytic_shell_mass, ke_pre)
c
      implicit none
#include "fortran_types.def"
#include "error.def"
#include "phys_const.def"
#define NO_FORTRAN_DEBUG
c
c     Arguments
c
      INTG_PREC nx, ny, nz, ic, jc, kc, idual, a, winds, deposit_unresolved
      INTG_PREC iface, jface, kface, imethod, imetal, imulti_metals,
     &          analytic_shell_mass
      R_PREC    d(nx, ny, nz), metal(nx,ny,nz), ge(nx,ny,nz),mu(nx,ny,nz)
      R_PREC    pu(nx,ny,nz), pv(nx,ny,nz), pw(nx,ny,nz), te(nx,ny,nz)
      R_PREC    metal_ejecta, m_eject, p_ej, e_sn, delta_metal, delta_m
      R_PREC    delta_e, p_units, zcell, e_units, t1, nb, dx
      R_PREC    dxf, dyf, dzf, dxc, dyc, dzc, tempx,xunits,
     &        dxf1, dyf1, dzf1, dxc1, dyc1, dzc1, odthresh
c
c     Locals
c
      INTG_PREC i, j, k, i1, j1, k1, n_sn
      R_PREC    delta_mass, delta_pu, delta_pv, delta_pw, delta_therm,
     &          dratio, tot_mass, temp, scalar_weight, p_t,p_rat,
     &          m_deposited, e_deposited, fz,m_units, d_units, m_cell,
     &          dmean, nmean, zmean, delta_z, e_couple, rc_mean, xba_mean,
     &          use_pt, mumean, dxRatio_mean, m_couple, m_shell, v_shell,
     &          p_couple
      R_PREC  fd(nx,ny,nz), fmetal(nx,ny,nz),
     &        fpu(nx,ny,nz), fpv(nx, ny, nz), fpw(nx,ny,nz)
      R_PREC  r_cool(3,3,3), ke_pre(3,3,3)
      R_PREC  delta_p(3), p_deposited(3)
      R_PREC  weightsFinal(3,3,3,3), nbor(3,3,3,3), xba(3,3,3,3)
      R_PREC  weights(3,3,3)
      R_PREC r_factor(3,3,3), mod_xba(3,3,3)
c
c     Error check
c

      if (imulti_metals .eq. 1_IKIND) then
         write(6,*) "momentum: not supported"
      endif
c
c     initialize a faux grid to deposit into
c
      do k = 1, nz
        do j = 1, ny
          do i = 1, nx
            fd(i,j,k) = 0._RKIND
            fmetal(i,j,k) = 0._RKIND
            fpu(i,j,k) = 0._RKIND
            fpv(i,j,k) = 0._RKIND
            fpw(i,j,k) = 0._RKIND
          enddo
        enddo
      enddo
      tot_mass = 0._RKIND
      temp = zcell / 0.02_RKIND
      if (temp .lt. 0.01_RKIND) then
          fz = 2._RKIND
      else
          fz = (temp)**(-0.14_RKIND)
      endif
      nb = d(ic,jc,kc)*d_units/mass_h/mu(ic,jc,kc)
      m_cell = d(ic, jc, kc)
      dmean = 0._RKIND
      mumean = 0._RKIND
c
c   Quantities needed for calculations; cooling radius r_cool,
c     scalar distance between particles mod_xba,
c     mean of density dmean, and mean of weight mumean
c
      do k = -1_IKIND, 1_IKIND
        do j = -1_IKIND, 1_IKIND
          do i = -1_IKIND, 1_IKIND
            dmean = dmean + d(ic+i, jc+j, kc+k)
            r_cool (i+2, j+2, k+2) = 28.4*pc_cm
     &                * (d(ic+i,jc+j,kc+k)*d_units/mass_h
     &                / mu(ic+i,jc+j, kc+k))**(-3.0/7.0)
     &                * (e_sn/1e51_RKIND*e_units)**(2.0/7.0)*fz
     &                /xunits ! code_length
            mod_xba(i+2,j+2,k+2) =
     &              sqrt(xba(i+2,j+2,k+2, 1)*xba(i+2,j+2,k+2,1)
     &                  + xba(i+2,j+2,k+2,2)*xba(i+2,j+2,k+2,2)
     &                  + xba(i+2,j+2,k+2,3)*xba(i+2,j+2,k+2,3))
            r_factor (i+2, j+2, k+2) =
     &              mod_xba(i+2,j+2, k+2)
     $                    / r_cool(i+2,j+2,k+2)
            mumean = mumean + mu(ic+i, jc+j, kc+k)
          enddo
        enddo
      enddo
      mod_xba(2,2,2) = 0._RKIND
c
c   To make ensure conservation and consistency, use values averaged over the
c     region around the feedback region to determine feedback parameters
c
      dmean = dmean / 27._RKIND
      mumean = mumean / 27._RKIND
      nmean = dmean*d_units / mass_h /mumean
      rc_mean = sum(r_cool)/27._RKIND
      xba_mean = sum(mod_xba)/26._RKIND
      dxRatio_mean = sum(r_factor)/26._RKIND
      use_pt = 0_IKIND
      e_couple = e_sn
c
c     According to Hopkins, we should use p = p_ej * min(sqrt(1+m_cell/m_ej), p_t/p_ej)), where
c       the first case implies r_cool is resolved.  Here, we have easy access to r_cool (and
c       it makes sense to think of distances in enzo instead of masses in gizmo) so if r_cool < xba,
c       the cooling radius is resolved.  else, we must decrease the coupled energy to account
c       for unresolved pdV work done by the blastwave (not really applicable to winds since they have such
c       lower coupled energy in the first place, r_cool is very, very small.).  The leftover
c       energy from winds is pushed into the host cell, while the mass from winds
c       is coupled to neighbors as usual.
c
c   Set which momentum to use in coupling
      if (dxRatio_mean .gt. 1._RKIND) use_pt = 1_IKIND
c
c   if cooling radius is small then the coupled momentum
c     and kinetic energy goes to zero
c
      if (1._RKIND / dxRatio_mean .lt. 1e-5_RKIND .and. use_pt .eq. 1_IKIND)
     &      e_couple = 0._RKIND
      ! if the grid is coarse enough and r_c is long,
      ! we want to ignore unrealistic long-distnace coupling
      if (rc_mean .gt. 2000 * 3.086e18_RKIND / xunits)
     &    e_couple = 0._RKIND
c
c   Else, energy is is scaled by (r_c/xba)^6.5
c
      if (use_pt .eq. 1_IKIND .and. e_couple .ne. 0._RKIND)
     &     e_couple = (dxRatio_mean)**(-6.5_RKIND)*e_sn
      if (e_couple .gt. e_sn) then
        write(0,*) "Coupled energy > ejected energy!", e_couple*e_units,
     &              e_sn*e_units, (rc_mean/xba_mean)**(6.5_RKIND)
        ERROR_MESSAGE
      endif
      if (isnan(e_couple)) then
        write(0,*) "wtf NaN energy"
        write(0,*) "rcmean =",rc_mean, "xba_mean = ",xba_mean,
     &        'winds = ', winds, 'e_sn = ', e_sn *e_units
        ERROR_MESSAGE
      endif
c
c   if not resolved r_cool for winds, inject as thermal energy in host cell
c     otherwise, winds have no effect whatsoever at low resolution.  Can
c     use same treatment of SNe using the DepositUnresolvedEnergyAsThermal
c     parameter
c
      if (e_couple .lt. e_sn) then
        if (deposit_unresolved .eq. 1_IKIND) then
          te(ic,jc,kc) = te(ic,jc,kc) + (e_sn-e_couple)/m_cell
          if (idual .eq. 1_IKIND)
     &        ge(ic,jc,kc) = ge(ic,jc,kc) + (e_sn-e_couple)/m_cell
          e_deposited = e_deposited + (e_sn-e_couple)*e_units
        endif
      endif
c
c    Set terminal momentum, if necessary, according to Cioffi 1988
c
      if (use_pt .eq. 1_IKIND) then
          p_t = (4.8e5_RKIND*(nmean**(-1._RKIND/7._RKIND))
     &            *  (e_couple*e_units/1e51_RKIND)**(13._RKIND/14._RKIND)
     &            * fz)
     &            / p_units
      endif
c
c   If using the terminal momenta, and if r_cool is anywhere near dx,
c     we should account for mass swept up in the snowplough phase that will
c     be distributed from the host cell, using that r_cool ~ R_pds from
c     Cioffi 1988
c
      p_couple = p_ej ![p_couple] = [code_momenta]
      if (use_pt .eq. 1_IKIND) p_couple=p_t
      m_couple = m_eject
      m_shell = 0._RKIND
      v_shell = 0._RKIND
      if (dxRatio_mean .lt. 100._RKIND .and.
     &    dxRatio_mean .gt. 0.1_RKIND .and.
     &    e_couple .gt. 0._RKIND .and.
     &    analytic_shell_mass .eq. 1_IKIND
     &    .and. winds .eq. 0_IKIND) then
        v_shell = 413._RKIND * nmean **(1._RKIND/7._RKIND)
     &          *(zcell/0.02_RKIND)**(3._RKIND/14._RKIND)
     &          *(e_couple*e_units/1e51_RKIND)**(1._RKIND/14._RKIND)
     &          *(dxRatio_mean)**(-7._RKIND/3._RKIND)
        ! [v_shell] = km/s
        m_shell = ((p_couple*p_units)/v_shell) /m_units![m_shell] = code_p/code_v = code_m
c
c
	 ! while we want to help cells evacuate, we dont want the cell density
	 ! to plunge too low compared to its neighbors, so limit
	 ! shell feedback to cells with density > 1/8 star forming density
	 ! that would not form stars
c
c
        do k = 0_IKIND, 1_IKIND
          do j = 0_IKIND, 1_IKIND
            do i = 0_IKIND, 1_IKIND
              if (d(ic+i,jc+j,kc+k) .le. 0.5*odthresh) then
                m_shell = 0.0
                goto 120
              endif
              if (m_shell/8._RKIND .gt. d(ic+i,jc+j,kc+k)) then
                m_shell = 0.5_RKIND*d(ic+i,jc+j,kc+k)
              endif
            enddo
          enddo
        enddo
 120    if (m_shell .gt. 0._RKIND) then
          m_couple = m_shell+m_eject
        endif
      endif
#ifdef FORTRAN_DEBUG
      write(*,*) "Feedback Qtys:"
      write(*,*) "Pars: analytic_shell = ", analytic_shell_mass, "use_pt = ", use_pt,
     &            "deposit thermal = ", deposit_unresolved
      write(*,*) "m_shell = ",m_shell*m_units,
     &    "p_coupled =", p_couple*p_units, "e_coupled =", e_couple*e_units,
     &    "thermal_coupled =", (e_sn-e_couple)*e_units,
     &    "v_shell =", v_shell, "dxRatio =",dxRatio_mean, "R_c = ", rc_mean*xunits,
     &    "dxMean = ", xba_mean*xunits, "dmean =", dmean*d_units, "nmean = ",nmean,
     &    "mumean = ",mumean
#endif
c
      do k = -1_IKIND, +1_IKIND
         do j = -1_IKIND, +1_IKIND
            do i = -1_IKIND, +1_IKIND
c
c     calculate mass, energy, momentum, etc for this cell particle
c
            if (i .eq. 0 .and. j .eq. 0 .and. k .eq. 0) cycle
            scalar_weight = weights(i+2, j+2, k+2)
            delta_m = m_couple * scalar_weight
            delta_e = e_couple * scalar_weight
            delta_metal = metal_ejecta * scalar_weight + m_shell*metal(ic,jc,kc)
            if (isnan(delta_metal)) then
              write(0,*) "nan Dmetal: z_ej = ",metal_ejecta*m_units,
     &                    'cell metal =', metal(ic,jc,kc),
     &                    'm_shell =', m_shell*m_units,
     &                    'i,j,k = ', i,j,k,
     &                    'weight = ',scalar_weight
              ERROR_MESSAGE
            endif
              do a = 1_IKIND, 3_IKIND
                temp = sqrt(1._RKIND+dmean/m_couple)
                if (use_pt .eq. 1_IKIND) then
                  delta_p(a) = p_couple * weightsFinal(i+2,j+2,k+2,a)
                else
                  delta_p(a) = p_couple *temp* weightsFinal(i+2,j+2,k+2,a)
                endif
                if (delta_m .eq. 0) delta_p(a) = 0._RKIND
              enddo

c
c     For each particle "cell", do CIC-like deposit
c     compute zone and face centered weight factors
c
               do k1 = k, k+1_IKIND
                  dzf1 = dzf
                  dzc1 = dzc
                  if (k1 .eq. k+1_IKIND) dzf1 = 1._RKIND - dzf
                  if (k1 .eq. k+1_IKIND) dzc1 = 1._RKIND - dzc
                  do j1 = j, j+1_IKIND
                     dyf1 = dyf
                     dyc1 = dyc
                     if (j1 .eq. j+1_IKIND) dyf1 = 1._RKIND - dyf
                     if (j1 .eq. j+1_IKIND) dyc1 = 1._RKIND - dyc
                     do i1 = i, i+1_IKIND
                        dxf1 = dxf
                        dxc1 = dxc
                        if (i1 .eq. i+1_IKIND) dxf1 = 1._RKIND - dxf
                        if (i1 .eq. i+1_IKIND) dxc1 = 1._RKIND - dxc
                        delta_mass =   delta_m*dxc1*dyc1*dzc1
                        delta_z = delta_metal*dxc1*dyc1*dzc1
                        delta_pu   =  delta_p(1)*dxf1*dyc1*dzc1
                        delta_pv   =  delta_p(2)*dxc1*dyf1*dzc1
                        delta_pw   =  delta_p(3)*dxc1*dyc1*dzf1
                        delta_therm = delta_e*dxc1*dyc1*dzc1
c
c     Add mass, momentum
c     (add thermal energy here)
c
                        dratio = d(ic+i1, jc+j1, kc+k1)/
     &                       (d(ic+i1, jc+j1, kc+k1) + delta_mass)
                        fd(ic+i1 ,jc+j1 ,kc+k1) = fd(ic+i1 ,jc+j1 ,kc+k1)
     &                       + delta_mass
                        fpu(iface+i1 ,jc+j1 ,kc+k1) =
     &                       fpu(iface+i1 ,jc+j1 ,kc+k1)+ delta_pu
                        fpv(ic+i1 ,jface+j1 ,kc+k1) =
     &                       fpv(ic+i1 ,jface+j1 ,kc+k1) + delta_pv
                        fpw(ic+i1 ,jc+j1 ,kface+k1) =
     &                       fpw(ic+i1 ,jc+j1 ,kface+k1)+ delta_pw
c
                        tot_mass = tot_mass + delta_mass
c#ifdef FORTRAN_DEBUG
                        p_deposited(1) = delta_pu**2 + p_deposited(1)
                        p_deposited(2) = delta_pv**2 + p_deposited(2)
                        p_deposited(3) = delta_pw**2 + p_deposited(3)
c#endif
c
c     Add increase in kinetic energy to the total energy field
c
                      temp = ((delta_pu*p_units)**2 + (delta_pv*p_units)**2
     &                                              + (delta_pw*p_units)**2)
     &                        / (2._RKIND*(d(ic+i1, jc+j1, kc+k1)*m_units)) ![p] = (Msun*km/s)^2/Msun = Msun (km/s)^2
                      temp = temp * SolarMass*1e10 ![temp] = erg
                      if (temp .gt. 1e51_RKIND) write(0,*) "HIGH E = ", temp
                      if (temp .lt. 0._RKIND) write(0,*) "negative energy = ", temp
                      ke_pre(i1+2, j1+2, k1+2) = ke_pre(i1+2, j1+2, k1+2) + temp
                      if (delta_mass .eq. 0._RKIND) temp = 0._RKIND

c
c     Metal feedback (note that in this function gas metal is
c     a fraction (rho_metal/rho_gas) rather than a density.
c     The conversion has been done in the handling routine)
c
                        if (imetal .eq. 1_IKIND) then
                           fmetal(ic+i1, jc+j1, kc+k1) =
     &                          fmetal(ic+i1, jc+j1, kc+k1) +
     &                          delta_z/d(ic+i1,jc+j1,kc+k1)
                           m_deposited = m_deposited +
     &                              delta_z

                        endif
c
c     End loop over CIC-deposit
c
                     enddo
                  enddo
               enddo
c
c     End loop over "cells" in particle-frame
c
            enddo
         enddo
      enddo

    !   Take shell mass out of the centralcells of the particle cloud.
    !    can't simply remove from host cell because that generates
    !    imbalances in momenta
      if (m_shell .gt. 0._RKIND) then
        do k = 0_IKIND, 1_IKIND
          do j = 0_IKIND, 1_IKIND
            do i = 0_IKIND, 1_IKIND
              if (m_shell/8._RKIND .gt. d(ic+i,jc+j,kc+k)) then
                write(6,*) "shell mass > cell mass!"
                write(6,*) "shell_mass = ", m_shell * m_units
                write(6,*) "cell_mass = ", d(ic+i,jc+j,kc+k) * m_units
                ERROR_MESSAGE
              endif
              d(ic+i,jc+j,kc+k) = d(ic+i,jc+j,kc+k) - m_shell/8._RKIND
            enddo
          enddo
        enddo
      endif
      do k = 1, nz
        do j = 1, ny
          do i = 1, nx
            d(i,j,k) = d(i,j,k)+fd(i,j,k)
            metal(i,j,k) = metal(i,j,k)+fmetal(i,j,k)
            pu(i,j,k) = pu(i,j,k)+fpu(i,j,k)
            pv(i,j,k) = pv(i,j,k)+fpv(i,j,k)
            pw(i,j,k) = pw(i,j,k)+fpw(i,j,k)
          enddo
        enddo
      enddo
c
c

        return
        end
c ==============================================================================
c
c ==============================================================================
c
c ==========================================================
c
c     Convert velocities to momentum and back
c
      subroutine mech_momentum(u, v, w, d, metal, up, vp, wp,
     &                    nx, ny, nz, ic, jc, kc,
     &                    iface, jface, kface, imethod, imetal, idir)
c
      implicit none
#include "fortran_types.def"
c
c     Arguments
c
      INTG_PREC nx, ny, nz, ic, jc, kc
      INTG_PREC iface, jface, kface, imethod, imetal, idir
      R_PREC    d(nx, ny, nz), metal(nx,ny,nz)
      R_PREC    u(nx,ny,nz), v(nx,ny,nz), w(nx,ny,nz)
      R_PREC    up, vp, wp
c
c     Locals
c
      INTG_PREC i, j, k
c
c     Error check
c
      if (idir .ne. -1_IKIND .and. idir .ne. 1_IKIND) then
        write(6,*) 'incorrect idir value in momentum call'
      endif
c
c     Loop over velocities, multiplying by densities (or dividing if
c       converting back)
c
      do k = -1_IKIND, +2_IKIND
        do j = -1_IKIND, +2_IKIND
          do i = -1_IKIND, +2_IKIND
c
c              idir = +1: convert vel -> mom
c
            if (idir. eq. +1_IKIND) then
               if (imethod .eq. 2_IKIND) then
                  u(iface+i ,jc+j ,kc+k) =
     &                    (u(iface+i ,jc+j ,kc+k) - up)
     &                    * 0.5_RKIND * (d(iface+i  , jc+j, kc+k) +
     &                    d(iface+i+1_IKIND, jc+j, kc+k))
                  v(ic+i ,jface+j ,kc+k) =
     &                    (v(ic+i ,jface+j ,kc+k) - vp)
     &                    * 0.5_RKIND * (d(ic+i, jface+j  , kc+k) +
     &                    d(ic+i, jface+j+1_IKIND, kc+k))
                  w(ic+i ,jc+j ,kface+k) =
     &                    (w(ic+i ,jc+j ,kface+k) - wp)
     &                    * 0.5_RKIND * (d(ic+i, jc+j, kface+k  ) +
     &                    d(ic+i, jc+j, kface+k+1_IKIND))
               else
                  u(ic+i ,jc+j ,kc+k) = (u(ic+i ,jc+j ,kc+k)-up) *
     &                                      d(ic+i, jc+j, kc+k)
                  v(ic+i ,jc+j ,kc+k) = (v(ic+i ,jc+j ,kc+k)-vp) *
     &                                      d(ic+i, jc+j, kc+k)
                  w(ic+i ,jc+j ,kc+k) = (w(ic+i ,jc+j ,kc+k)-wp) *
     &                                      d(ic+i, jc+j, kc+k)
               endif
               if (imetal .eq. 1_IKIND) then
                  metal(ic+i,jc+j,kc+k) = metal(ic+i,jc+j,kc+k) *
     &                    d(ic+i,jc+j,kc+k)
               endif
c
c              if idir = -1: convert mom -> vel
c
            else
               if (imethod .eq. 2_IKIND) then
                  u(iface+i ,jc+j ,kc+k) = u(iface+i ,jc+j ,kc+k)
     &                    /( 0.5_RKIND * (d(iface+i  , jc+j, kc+k) +
     &                             d(iface+i+1_IKIND, jc+j, kc+k))) + up
                  v(ic+i ,jface+j ,kc+k) = v(ic+i ,jface+j ,kc+k)
     &                    /( 0.5_RKIND * (d(ic+i, jface+j  , kc+k) +
     &                             d(ic+i, jface+j+1_IKIND, kc+k))) + vp
                  w(ic+i ,jc+j ,kface+k) = w(ic+i ,jc+j ,kface+k)
     &                    /( 0.5_RKIND * (d(ic+i, jc+j, kface+k  ) +
     &                             d(ic+i, jc+j, kface+k+1_IKIND))) + wp
               else
                  u(ic+i ,jc+j ,kc+k) = u(ic+i ,jc+j ,kc+k) /
     &                                     d(ic+i, jc+j, kc+k) + up
                  v(ic+i ,jc+j ,kc+k) = v(ic+i ,jc+j ,kc+k) /
     &                                     d(ic+i, jc+j, kc+k) + vp
                  w(ic+i ,jc+j ,kc+k) = w(ic+i ,jc+j ,kc+k) /
     &                                     d(ic+i, jc+j, kc+k) + wp
               endif
               if (imetal .eq. 1_IKIND) then
                  metal(ic+i,jc+j,kc+k) = metal(ic+i,jc+j,kc+k) /
     &                    d(ic+i,jc+j,kc+k)
               endif
            endif
c
         enddo
      enddo
      enddo
c
      return
      end
