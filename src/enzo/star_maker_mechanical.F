#include "fortran.def"
#include "phys_const.def"
#include "error.def"

c=======================================================================
c////////////////////////  SUBROUTINE STAR_MAKER \\\\\\\\\\\\\\\\\\\\\\\
c
      subroutine star_maker_mechanical(nx, ny, nz,
     &                      d, dm, temp, u, v, w,
     &                      dt, r, metal, zfield1, zfield2,
     &                      dx, t, z, procnum,
     &                      dunits, x1, vunits, t1,
     &                      nmax, xstart, ystart, zstart, ibuff,
     &                      imetal, imethod, mintdyn,
     &                      odthresh, level, np,
     &                      xp, yp, zp, up, vp, wp,
     &                      mp, tdp, tcp, metalf, max_form_mass)

c
c  CREATES STAR PARTICLES FOR KINETIC FEEDBACK
c
c
c  INPUTS:
c
c    d     - density field
c    dm    - dark matter field
c    temp  - temperature field
c    u,v,w - velocity fields
c    cooltime - cooling time in code units
c    r     - refinement field (non-zero if zone is further refined)
c    dt    - current timestep
c    dx    - zone size (code units)
c    t     - current time
c    z     - current redshift
c    dunits,x1,vunits,t1 - factors to convert d,dx,v,t to physical units
c    nx,ny,nz - dimensions of field arrays
c    ibuff    - number of buffer zones at each end of grid
c    imethod  - Hydro method (0/1 -- PPM DE/LR, 2 - ZEUS)
c    odthresh - overdensity threshold (some number * avg. density)
c    masseff - gas-to-mass conversion efficiency ( 0<=masseff<=1 )
c    smthresh - star mass threshold (only creates stars with mass >
c        smthresh unless (random number) < starmass/smthresh )
c    mintdyn  - minimum dynamical time, in years
c    level - current level of refinement
c    procnum - processor number (for output)
c    imetalSNIa - SN Ia metallicity flag (0 - none, 1 - yes)
c
c  OUTPUTS:
c
c    np   - number of particles created
c    x/y/z start - starting position of grid origin
c    xp,yp,zp - positions of created particles
c    up,vp,wp - velocities of created particles
c    mp       - mass of new particles
c    tdp      - dynamical time of zone in which particle created
c    tcp      - creation time of particle
c    metalf   - metallicity fraction of particle
c    nmax     - particle array size specified by calling routine
c    metalfSNIa - metallicity fraction of particle (from SN Ia) ! MKRJ
c
c
c-----------------------------------------------------------------------
       implicit none
#include "fortran_types.def"
#define NO_FORTRAN_DEBUG
c-----------------------------------------------------------------------
c
c  Arguments
c
      INTG_PREC nx, ny, nz, ibuff, nmax, np, level, imetal, imethod
      INTG_PREC procnum, imetalSNIa
      R_PREC    d(nx,ny,nz), dm(nx,ny,nz), temp(nx,ny,nz)
      R_PREC    u(nx,ny,nz), v(nx,ny,nz), w(nx,ny,nz)
      R_PREC    r(nx,ny,nz), cooltime(nx,ny,nz)
      R_PREC    metal(nx,ny,nz), zfield1(nx,ny,nz), zfield2(nx,ny,nz)
      R_PREC    dt, dx, z, exptime, max_form_mass
      R_PREC    dunits, x1, vunits, t1
      P_PREC xstart, ystart, zstart, t
      P_PREC xp(nmax), yp(nmax), zp(nmax)
      R_PREC    up(nmax), vp(nmax), wp(nmax)
      R_PREC    mp(nmax), tdp(nmax), tcp(nmax), metalf(nmax)
      R_PREC    metalSNIa(nx,ny,nz), metalfSNIa(nmax)
      R_PREC    odthresh, masseff, smthresh, mintdyn
c
      R_PREC   sformsum
      save   sformsum
      data   sformsum/0/
c
c  Locals:
c
      INTG_PREC  i, j, k, ii
      R_PREC   div, tdyn, dtot
      R_PREC   pi, G, sndspdC
      R_PREC   isosndsp2, starmass, starfraction, bmass, jeanmass
      R_PREC   max_mass, grad_rho, tau, phi, psi, f_s, t_ff, m_units
      R_PREC msolar
      parameter (pi=pi_val, G=GravConst,
     &           sndspdC=1.3095e8_RKIND,
     &           msolar=SolarMass)
c
      ii = np
      max_mass = max_form_mass * msolar /dunits/dx**3/x1**3
!     print*,'star_maker3: imetal is:',imetal

c
c  for each zone, : "star" particle is created if answers to all the
c  following questions are affirmative:
c
c    is this the finest level of refinement ?
c    is the density greater than a critical density ?
c    is the flow convergent ?
c    is the cooling time less than a dynamical time ?
c    is the gas mass greater than the Jeans mass?
c
      do k=1+ibuff,nz-ibuff
         do j=1+ibuff,ny-ibuff
            do i=1+ibuff,nx-ibuff
c
c              1) is this finest level of refinement?
c
               if (r(i,j,k) .ne. 0._RKIND) goto 10
c
c              2) is density greater than threshold?

               if (d(i,j,k) .lt. odthresh) goto 10
c
c              3) is divergence negative?
c                 (the first calculation is face centered for ZEUS,
c                  the second is cell-centered for PPM)
c
               if (imethod .eq. 2) then
                  div = u(i+1,j  ,k  ) - u(i,j,k)
     &                + v(i  ,j+1,k  ) - v(i,j,k)
     &                + w(i  ,j  ,k+1) - w(i,j,k)
               else
                  div = u(i+1,j  ,k  ) - u(i-1,j  ,k  )
     &                + v(i  ,j+1,k  ) - v(i  ,j-1,k  )
     &                + w(i  ,j  ,k+1) - w(i  ,j  ,k-1)
               endif
               if (div .ge. 0._RKIND) goto 10
c
c              4) t_cool < t_free-fall (if T < 1.1e4 skip this check)
c
               dtot = ( d(i,j,k) + dm(i,j,k) )*dunits
               tdyn  = sqrt(3._RKIND*pi/32._RKIND/G/dtot)/t1

               if (tdyn .lt. cooltime(i,j,k) .and.
     &             temp(i,j,k) .gt. 1.1e4_RKIND) goto 10
c
c              5) is M > M_Jeans? (this definition involves only baryons under
c                 the assumption that the dark matter is stable, which
c                 implies that the dark matter velocity dispersion is >>
c                 the sound speed.  This will be true for small perturbations
c                 within large halos).
c
               bmass = d(i,j,k)*dble(dunits)*dble(x1*dx)**3 / msolar
               isosndsp2 = sndspdC * temp(i,j,k)
               jeanmass = pi/(6._RKIND*sqrt(d(i,j,k)*dble(dunits))) *
     &                    dble(pi * isosndsp2 / G)**1.5_RKIND / msolar

c
c  THIS IS COMMENTED OUT - NO JEANS MASS CRITERION IN THIS ALGORITHM!!!
c  BWO, 13 NOV 02 (fix 3 dec 02)
               if (jeanmass .gt. max(bmass, 1e3_RKIND)) goto 10
c
c              6) Check to see if star is above threshold (given
c                 in units of M_solar)
c
               starfraction = min(masseff*dt/tdyn, 0.9_RKIND)
               tdyn = max(tdyn, mintdyn*3.15e7_RKIND/t1)

c
c  STOCHASTIC STAR FORMATION HAS BEEN ADDED AGAIN - BWO 20 Dec 2002
c
#define NO_STOCHASTIC_STAR_FORMATION
c
#ifdef STOCHASTIC_STAR_FORMATION
c
c                 Keep global count of "unfullfilled" star formation
c                 and when total is larger than threshold, then create
c                 a star particle with the threshold mass or 1/2 the
c                 gas in the cell, whichever is smaller.
c
               if (starfraction*bmass .lt. smthresh) then
                  sformsum = sformsum + starfraction*bmass
                  if (sformsum .lt. smthresh) goto 10
                  starfraction = min(smthresh/bmass, 0.5_RKIND)
                  sformsum = sformsum - starfraction*bmass
               endif
#endif
c
c              is star mass greater than threshold, then make it.
c              if it's less than threshold, go to the next cell.
c
              grad_rho = sqrt(((d(i+1, j, k)
     &                          - d(i-1, j, k))*dunits)**2_RKIND
     &                  + ((d(i, j+1, k) -d(i, j-1, k))*dunits)**2_RKIND
     &                  + ((d(i, j, k+1) - d(i,j,k-1))*dunits)**2_RKIND)
              tau = 434.8_RKIND * d(i,j,k)*dunits
     &                    * (dx*x1 + d(i,j,k) * dunits/grad_rho)
              phi = 0.756_RKIND *
     &           (1._RKIND+ 3.1_RKIND*metal(i,j,k)
     &           /0.02_RKIND)**0.365_RKIND
              psi = (0.6_RKIND * tau
     &               * (0.01+metal(i,j,k)/0.02_RKIND))
     &               / (log(1_RKIND+0.06_RKIND
     &               * phi + 0.01_RKIND
     &               * (phi)**2_RKIND))
              f_s = 1._RKIND - 3._RKIND/(1._RKIND+ 4._RKIND*psi)
               if (f_s .le. 0._RKIND) goto 10
               write(6,*) "shielded fraction: ", f_s
               if (f_s .gt. 1._RKIND) f_s = 1._RKIND
               t_ff = sqrt(3._RKIND*dble(pi / (32._RKIND * G * d(i,j,k)*dunits)))/t1
c
c              Create a star particle
c
               ii = ii + 1
               mp(ii)  =  max(0.001_RKIND * d(i,j,k),
     &                    min(f_s * d(i,j,k)/t_ff, max_mass))
               if (mp(ii) .gt. d(i,j,k)) then
                write(6,*) "Fatal Error: Mass of star > Mass of cell"
                ERROR_MESSAGE
               endif
               tcp(ii) = t
               tdp(ii) = tdyn
c              If discrete explosions are used, then use tdp as
c              a flag indicating whether the particle has done
c              feedback rather than dynamical time field
               if (exptime .ge. 0._RKIND) then
                  tdp(ii) = 1._RKIND
               endif
               xp(ii) = xstart + (REAL(i,RKIND)-0.5_RKIND)*dx
               yp(ii) = ystart + (REAL(j,RKIND)-0.5_RKIND)*dx
               zp(ii) = zstart + (REAL(k,RKIND)-0.5_RKIND)*dx
c
c              Star velocities averaged over multiple cells to
c              avoid "runaway star particle" phenomenon
c              imethod = 2 is zeus, otherwise PPM

               if (imethod .eq. 2) then
                  up(ii) = 0.5_RKIND*(u(i,j,k)+u(i+1,j,k))
                  vp(ii) = 0.5_RKIND*(v(i,j,k)+v(i,j+1,k))
                  wp(ii) = 0.5_RKIND*(w(i,j,k)+w(i,j,k+1))
               else
                  up(ii) = u(i,j,k)
                  vp(ii) = v(i,j,k)
                  wp(ii) = w(i,j,k)
               endif
c
c              Set the particle metal fraction
c
               if (imetal .eq. 1) then
!                 write(*,'("Setting metal fraction")')
                  metalf(ii) = metal(i,j,k)    ! in here metal is a fraction
               else
!                 write(*,'("Zero metal fraction")')
                  metalf(ii) = 0._RKIND
               endif
c
c              MKRJ 2/20/08 Do the same for particle metal fraction from SN Ia
c
               if (imetalSNIa .eq. 1) then
                  metalfSNIa(ii) = metalSNIa(i,j,k)    ! in here metal is a fraction
               endif
c
c              Remove mass from grid
c
               d(i,j,k) = d(i,j,k) - mp(ii)
c
c               write(7+procnum,1000) level,bmass*starfraction,tcp(ii),
c     &                           tdp(ii)*t1,d(i,j,k)*dunits,z,metalf(ii)
c
 1000          format(i5,1x,6(1pe10.3,1x))
c
c              Do not generate more star particles than available
c
               if (ii .eq. nmax) goto 20

10          continue

            enddo
         enddo
      enddo
 20   continue
c
      if (ii .ge. nmax) then
         write(6,*) 'star_maker3: reached max new particle count'
         ERROR_MESSAGE
      endif
      np = ii
c
c      if (np .ne. 0) then
c         write(6,*) 'Stars created: number,time,level: ', np, t, level
c      endif
c
      return
      end
c
c
c
c===================================================================================
c////////////////////// SUBROUTINE STAR FEEDBACK MECHANICAL \\\\\\\\\\\\\\\\\\\\\\\\
c
c
c    Routine to handle mechanical feedback from stars.  Creation is handled as
c    star_maker3mom, i.e., Cen & Ostriker stochastic formation but with stars given
c    the bulk velocity of progenitor gas.
c
c
c    If SingleSN = 1, Supernova are handled discretely, drawing the probability of a SN II, Ia.
c    Stars stay active indefinitely (until a lower mass limit to prevent
c    negative mass stars), feeding back winds based on the age of the
c    particle:
c    young particles have strong & fast winds from OB stars, old particles
c    have slow winds from AGB.
c
c     This was imported from a very early version of enzo, and is missing some feed-
c     back types: SNIa, cosmic rays, etc.
c=======================================================================
c/////////////////////  SUBROUTINE STAR_FEEDBACK \\\\\\\\\\\\\\\\\\\\\\\
c
      subroutine star_feedback_mechanical(nx, ny, nz,
     &               mu_field, d, dm, te, ge, u, v, w,
     &               metal, zfield1, zfield2,
     &               idual, imetal, imulti_metals, imethod,
     &               dt, r, dx, t, z, h, omegaM, omegaL,
     &               dunits, x1, vunits, t1,
     &               npart, xstart, ystart, zstart, ibuff,
     &               xp, yp, zp, up, vp, wp,
     &               mp, tdp, tcp, metalf, type,
     &               star_winds, single_sn, max_star_mass,
     &               odthresh)

c
c  RELEASES "STAR" PARTICLE ENERGY, MASS AND METALS
c
c  written by: Azton Wells
c  date:      Jan 2019
c
c
c  INPUTS:
c
c    d     - density field
c    dm    - dark matter field
c    te,ge - total energy and gas energy fields
c    u,v,w - velocity fields
c    metal - metallicity density field
c    r     - refinement field (0 if zone is further refined)
c    dt    - current timestep
c    dx    - zone size (code units)
c    t     - current time
c    z     - current redshift
c    h     - hubble constant at z=0 km/s/mpc
c    O_m   - omega_matter at z=0
c    O_l   - omega_lambda at z=0
c    dunits,x1,vunits,t1 - factors to convert d,dx,v,t to physical units
c    nx,ny,nz - dimensions of field arrays
c    ibuff    - number of buffer zones at each end of grid
c    idual    - dual energy flag
c    imetal   - metallicity flag (0 - none, 1 - yes)
c    imulti_metals - flag to use multi metals zfield 1 and 2
c    imethod  - hydro method (0 - PPMDE, 1 - PPMLR, 2 - ZEUS)
c    distrad  - feedback distribution radius in cells
c    diststep - distance in walking steps to deposit feedback
c    distcells - total number of cells over which to distribute feedback
c
c    x/y/z start - starting position of grid origin
c    xp,yp,zp - positions of created particles
c    up,vp,wp - velocities of created particles
c    mp       - mass of new particles
c    tdp      - dynamical time of zone in which particle created or
c               if exptime >= 0, a flag for whether the discrete
c               explosion has occurred
c    tcp      - creation time of particle (-1 if not a star particle)
c    metalf   - star particle metal fraction
c    npart    - particle array size specified by calling routine
c    yield    - fraction of stellar mass that is converted to metals
c    type     - particle type
c    star_winds - flag to use continuous winds (stellar mass loss)
c    discrete_sn - flag to use discrete sn or continuous injection
c
c  OUTPUTS:
c    d,u,v,w,ge,e - modified field
c    justburn     - time-weighted mass of star formation (code units)
c
c
c-----------------------------------------------------------------------
       implicit none
#include "fortran_types.def"
#include "phys_const.def"
c-----------------------------------------------------------------------
#define NO_FORTRAN_DEBUG
c
c  Arguments
c
      INTG_PREC nx, ny, nz, ibuff, npart, idual, imetal,
     &      imulti_metals, imethod, single_sn,
     &      distrad, diststep, distcells, star_winds
      R_PREC    d(nx,ny,nz), dm(nx,ny,nz), te(nx,ny,nz)
      R_PREC    u(nx,ny,nz), v(nx,ny,nz), w(nx,ny,nz)
      R_PREC    r(nx,ny,nz), ge(nx,ny,nz)
      R_PREC    metal(nx,ny,nz), mu_field(nx,ny,nz)
      R_PREC    zfield1(nx,ny,nz), zfield2(nx,ny,nz)
      R_PREC    dt, dx, z, h, omegaM, omegaL, max_star_mass
      R_PREC    dunits, x1, vunits, t1, justburn
      R_PREC xstart, ystart, zstart, t
      R_PREC xp(npart), yp(npart), zp(npart)
      R_PREC    up(npart), vp(npart), wp(npart)
      R_PREC    mp(npart), tdp(npart), tcp(npart), metalf(npart)
      INTG_PREC type(npart)
c
c
c  Locals
c
c
c    (msolar_e51 is one solar rest mass energy divided by 10^51 erg)
c
      INTG_PREC n, ic, jc, kc, ip, jp, kp,
     &            i, j, k, a, ax, p, one_event
      INTG_PREC n_sn_ii, n_sn_ia, iface, jface, kface
      R_PREC mform, zcell, f_factor,
     &         odthresh, div, grad_rho, dcell, acell,
     &         tau_cell, phi_cell, psi_cell, f_shielded,
     &         t_ff, m_form, modxba, num, denom, rmp, rpm,
     &         sum_weights, sum_factor, wind_factor, psi_k, temp,
     &         hcell, metal_ejecta
      R_PREC R_ii, R_ia, m_eject, m_winds, wind_metal, snii_metals,
     &          snia_metals, e_sn, p_ej, v_wind,
     &          e_wind, P_ii, P_ia, adotx, m_units,
     &          m_deposited, e_deposited, p_units, e_units
      R_PREC mag_xba(3,3,3)
      R_PREC f(3,2)
      R_PREC xba(3,3,3,3), p_deposited(3), ahats(3,3,3,3)
      R_PREC nbor(3,3,3,3)
      R_PREC weightsFinal(3,3,3,3)
      R_PREC weights(3,3,3)
      R_PREC pm(3,3,3,3,2)
      R_PREC dxf, dyf, dzf, dxc, dyc, dzc, xfc, yfc, zfc,
     &     xfcshift,yfcshift,zfcshift, xpos, ypos, zpos,
     &     xface, yface, zface, face_shift
      R_PREC Zsol, energy_51, eunits, e_const, ergs_51, fbuff, pi
      R_PREC msolar, msolar_e51, mH, g, mstar, age, max_mass, sn_eject

      R_PREC tempx, tempy, tempz
c    external random
      real random
c      call random_seed
c
c-----------------------------------------------------------------------
c
c     Loop over particles
c
      if (imethod .ne. 0) then
        write (6,*) 'mechanical feedback only',
     &    ' works with PPM hydro solver! method= ',imethod
        ERROR_MESSAGE
      endif
      one_event = 0._RKIND ! flag for testing: =1 implies only one sn at first step. Can be set to N-events
      msolar = SolarMass ! grams per m_sol
      pi = 3.14159265358979323846_RKIND
      g = GravConst
      acell = 1._RKIND/(1_RKIND + z)
      m_units = dunits * (x1)**3*dx**3 / msolar     ! Msun
      e_units = dunits * x1**5*dx**3  /t1**2 ! ergs
      p_units = sqrt(m_units*msolar*e_units)/1e5/msolar ! Msun*km/s
      max_mass = max_star_mass / m_units
c
c   Loop over particles
c
      do n=1_IKIND, npart
        if (tcp(n) .gt. 0._RKIND .and.
     &          mp(n) .gt. 20.0/m_units .and.
     &          type(n) .eq. 2_IKIND) then
c
c   center of feedback zone
c
            ip = int((xp(n) - xstart)/dx) + 1_IKIND
            jp = int((yp(n) - ystart)/dx) + 1_IKIND
            kp = int((zp(n) - zstart)/dx) + 1_IKIND

            if (xp(n) .lt. xstart .or. xp(n) .gt. xstart+dx*nx .or.
     &          yp(n) .lt. ystart .or. yp(n) .gt. ystart+dx*ny .or.
     &          zp(n) .lt. zstart .or. zp(n) .gt. zstart+dx*nz) then
               write(6,*) 'warning: star particle out of grid',
     &              xp(n),yp(n),zp(n), xstart, ystart, zstart, ip,jp,kp
               goto 100
            endif
c
c	Set center of feedback zone
c
            xfc = xp(n)
            yfc = yp(n)
            zfc = zp(n)
            fbuff = ibuff + 2._RKIND
            mstar = mp(n) * m_units
c#ifdef FORTRAN_DEBUG
            write(0,*) 'mp pre',mstar
c#endif
c
c         check bounds - if star particle is near grid edge
c         then shift center of feedback region
c
            if (xfc .lt. xstart+fbuff*dx .or.
     &          xfc .gt. xstart+dx*nx-fbuff*dx .or.
     &          yfc .lt. ystart+fbuff*dx .or.
     &          yfc .gt. ystart+dx*ny-fbuff*dx .or.
     &          zfc .lt. zstart+fbuff*dx .or.
     &          zfc .gt. zstart+dx*nz-fbuff*dx) then
#ifdef FORTRAN_DEBUG
               write(6,*) 'warning1: star feedback zone shifted',
     &              xfc,yfc,zfc, xstart, ystart, zstart,fbuff
#endif
c
	       xfcshift = xfc
	       yfcshift = yfc
	       zfcshift	= zfc
c
	       xfc = max(xfc,xstart+fbuff*dx)
	       yfc = max(yfc,ystart+fbuff*dx)
	       zfc = max(zfc,zstart+fbuff*dx)
c
	       xfc = min(xfc,xstart+dx*nx-fbuff*dx)
	       yfc = min(yfc,ystart+dx*ny-fbuff*dx)
	       zfc = min(zfc,zstart+dx*nz-fbuff*dx)
c
	       xfcshift = xfcshift - xfc
	       yfcshift = yfcshift - yfc
	       zfcshift	= zfcshift - zfc
c
#ifdef FORTRAN_DEBUG
	       write(6,*) 'warning2: star feedback zone shifted',
     &              xfc,yfc,zfc,dx,xfcshift,yfcshift,zfcshift,
     &		    nx, ny,nz
#endif
            endif
            xpos = (xfc - xstart)/dx - 0.5_RKIND
            ypos = (yfc - ystart)/dx - 0.5_RKIND
            zpos = (zfc - zstart)/dx - 0.5_RKIND
            ic = int(xpos + 0.5_RKIND)
            jc = int(ypos + 0.5_RKIND)
            kc = int(zpos + 0.5_RKIND)
c#ifdef FORTRAN_DEBUG
c            write(6,*) 'new index: ',ic,jc,kc
c#endif
c
c    7/?  Transform to comoving coords
c
c
            call mech_momentum(u,v,w,d,metal,up(n), vp(n), wp(n),
     &                        nx, ny, nz, ic, jc, kc,
     &                        iface, jface, kface,
     &                        imethod, imetal, +1_IKIND)
            face_shift = 0._RKIND
            if (imethod .eq. 2) face_shift = 0.5_RKIND
            dxc = real(ic) + 0.5_RKIND - xpos
            dyc = real(jc) + 0.5_RKIND - ypos
            dzc = real(kc) + 0.5_RKIND - zpos
c
c         Compute index of the first cell to add momentum,
c             accounting for possible face-centering
c
            xface = (xfc - xstart)/dx - 0.5_RKIND - face_shift
            yface = (yfc - ystart)/dx - 0.5_RKIND - face_shift
            zface = (zfc - zstart)/dx - 0.5_RKIND - face_shift
c
            iface = int(xface + 0.5_RKIND)
            jface = int(yface + 0.5_RKIND)
            kface = int(zface + 0.5_RKIND)
c
            dxf = real(iface) + 0.5_RKIND - xface
            dyf = real(jface) + 0.5_RKIND - yface
            dzf = real(kface) + 0.5_RKIND - zface

c    1/?  Check for continual formation:
c              a.)  require gas still be dense enough for
c                   self shielding using local Sobolev approximation
c                   and that overdensity is > n.
c
c              b.)  make sure divergence of gas flow is still negative
c              c.)  need M_jeans < m_crit
c
            mform = 0._RKIND
            zcell = metal(ic, jc, kc)
            dcell = d(ic,jc,kc) * dunits

            m_deposited = 0._RKIND
            e_deposited = 0._RKIND
            do i = 1_IKIND, 3_IKIND
              p_deposited(i) = 0._RKIND
            enddo
c
c           a.) divergence of the gas
c
            if (imethod .eq. 2) then
                  div = u(ic+1,jc  ,kc  ) - u(ic,jc,kc)
     &                + v(ic  ,jc+1,kc  ) - v(ic,jc,kc)
     &                + w(ic  ,jc  ,kc+1) - w(ic,jc,kc)
            else
                  div = u(ic+1,jc  ,kc  ) - u(ic-1,jc  ,kc  )
     &                + v(ic  ,jc+1,kc  ) - v(ic  ,jc-1,kc  )
     &                + w(ic  ,jc  ,kc+1) - w(ic  ,jc  ,kc-1)
            endif

c
c           c.) calculate shielded fraction via Krumholz & Gnedin 2011
c
            hcell = dx*x1
            grad_rho = sqrt((d(ic+1, jc, kc) - d(ic-1, jc, kc))**2._RKIND*dunits
     &                  + (d(ic, jc+1, kc) -d(ic, jc-1, kc))**2._RKIND*dunits
     &                  + (d(ic, jc, kc+1) - d(ic,jc,kc-1))**2._RKIND*dunits)
            tau_cell = 434.8_RKIND * dcell * (dx *x1+ dcell/(grad_rho))
            phi_cell = 0.756_RKIND * (1+ 3.1_RKIND*zcell/0.02_RKIND)**0.365_RKIND
            psi_cell = (0.6_RKIND * tau_cell * (0.01+zcell/0.02_RKIND))
     &               / (log(1_RKIND+0.06_RKIND * phi_cell + 0.01_RKIND
     &               * (phi_cell)**2_RKIND))
            f_shielded = 1_RKIND - 3_RKIND/(1_RKIND+ 4_RKIND*psi_cell)
            if (div .le. 0._RKIND .and. d(ic,jc,kc) .ge. odthresh
     &        .and. f_shielded .gt. 0._RKIND
     &        .and. mp(n) .le. max_mass) then
              t_ff = sqrt(3._RKIND*pi / (32._RKIND * g * dcell))/t1
#ifdef FORTRAN_DEBUG
              write(0,*) 'f, tff, d, dt: ',f_shielded,
     &              t_ff*t1, d(ic,jc,kc)*m_units, dt
#endif
              m_form = dt * f_shielded
     &                  *d(ic,jc,kc)*m_units / (t_ff)
            else
              m_form = 0._RKIND
            endif
c           add mass to star particle
#ifdef FORTRAN_DEBUG
            write(6,*) 'mass formed: ', m_form/m_units
#endif
           m_form = m_form / m_units
            if (m_form .gt. 0._RKIND .and. m_form .lt. 0.1*mp(n)
     &              .and. mp(n) .lt. max_mass)
     &              mp(n) = mp(n) + m_form
            if (m_form .gt. 0.1*mp(n)) then
                write(6,*) 'M_form too large', m_form*m_units
                m_form = 0.1*mp(n)
                mp(n) = mp(n) + m_form
            endif
c#ifdef FORTRAN_DEBUG
            write(0,*) 'mass added to ptcl: ', m_form*m_units
c#endif
            mstar = mp(n) * m_units
c
c           remove mass from the grid cell.
c
            d(ic, jc, kc) = d(ic, jc, kc) - m_form
c
c
c    2/?  Construct the 3x3 mask to distribute feedback.
c                 make arrays of neighbor positions (x,y,z),
c                 weights.  The weights estimate the amount of
c                 feedback that will be deposited to cell 'b'
c                 and is calculated as in Hopkins, 2017
c
c
c           get a list of positions of neighbor "particles"
c    __ Construct Neighbor particle mask that acts as coupled particles for deposition
c

            do k = 1_IKIND, 3_IKIND
              do j = 1_IKIND, 3_IKIND
                do i = 1_IKIND, 3_IKIND
                  nbor(i,j,k, 1) = xp(n) + dx * (i - 2)
                  nbor(i,j,k, 2) = yp(n) + dx * (j - 2)
                  nbor(i,j,k, 3) = zp(n) + dx * (k - 2)
                  xba(i,j,k, 1) = dx * (i - 2)
                  xba(i,j,k, 2) = dx * (j - 2)
                  xba(i,j,k, 3) = dx * (k - 2)
                  mag_xba(i,j,k) = 0._RKIND
                enddo
              enddo
            enddo
c
c
c    __ Construct Wieghts vector.  Each entry is the fraction of energy that goes into that
c               coupling particle
c
c           __ Area vector for A.dot(xba)
c                 generate vector that has scalar xba^2
            do k = 1_IKIND, 3_IKIND
              do j = 1_IKIND, 3_IKIND
                do i = 1_IKIND, 3_IKIND
                  do ax = 1_IKIND, 3_IKIND
                    mag_xba(i,j,k) = mag_xba(i,j,k)
     &                        + xba(i,j,k,ax)*xba(i,j,k,ax)
                  enddo
                enddo
              enddo
            enddo
c
c         Make ahat vector; entries point from xp to fb particle
c
            do k = 1_IKIND, 3_IKIND
              do j = 1_IKIND, 3_IKIND
                do i = 1_IKIND, 3_IKIND
                  do ax = 1_IKIND, 3_IKIND
                    ahats(i,j,k,ax) = 4.8_RKIND*pi/26._RKIND
     &                             * xba(i,j,k,ax)/sqrt(mag_xba(i,j,k))
                  enddo
                enddo
              enddo
            enddo
c
c
c    __ Make array of scalar weights that determine fraction of
c         feedback that goes into the neighbor particles.
c
            sum_weights= 0.0_RKIND
            do k = 1_IKIND, 3_IKIND
              do j = 1_IKIND, 3_IKIND
                do i = 1_IKIND, 3_IKIND
                  if (i .eq. 2_IKIND
     &                  .and. j .eq. 2_IKIND
     &                  .and. k .eq. 2_IKIND) then
                    weights(i,j,k) = 0._RKIND
                  else
                    temp = 0._RKIND
                    do ax = 1_IKIND, 3_IKIND
                      temp = temp + ahats(i,j,k,ax)
     &                      * xba(i,j,k,ax)/sqrt(mag_xba(i,j,k))
                    enddo
                    weights(i,j,k) = sqrt(1._RKIND
     &                            + temp/(pi*mag_xba(i,j,k)))
                    sum_weights = sum_weights + weights(i,j,k)
                  endif
                enddo
              enddo
            enddo
            do k= 1_IKIND, 3_IKIND
              do j= 1_IKIND, 3_IKIND
                do i = 1_IKIND,3_IKIND
                  weights(i,j,k) = weights(i,j,k) / sum_weights
                enddo
              enddo
            enddo
c            tempx = 0._RKIND
            tempy = 0._RKIND
            tempz = 0._RKIND
c            write(6,*) 'Final Weights:'
            do k= 1_IKIND, 3_IKIND
              do j= 1_IKIND, 3_IKIND
                do i = 1_IKIND,3_IKIND
                  do ax = 1_IKIND, 3_IKIND
                    if (i == 2_IKIND .and. j == 2_IKIND
     &                .and. k == 2_IKIND) then
                      weightsFinal(i,j,k,ax) = 0.0_RKIND
                      continue
                    else
                      weightsFinal(i,j,k,ax) =
     &                      xba(i,j,k, ax)/sqrt(mag_xba(i,j,k))
     &                            *weights(i,j,k)
                    endif
                  enddo
                  tempy = tempy + weightsFinal(i,j,k,2)
                  tempz = tempz + weightsFinal(i,j,k,3)
                enddo
              enddo
            enddo
c#ifdef FORTRAN_DEBUG
c            write(6,*) 'Sum weights: ', tempx*m_units,
c     &                      tempy*m_units , tempz*m_units
c#endif
c
c               Although Hopkins 2017 has tensor corrections using plus/minus
c                 vectors, this formulation does not require it, since
c                 the coupled particles are symmetric about the
c                 star particle.
c
c
c    3/?  if age is low enough, check for supernova
c              rates are per solar mass per Myr
            R_ii = 0._RKIND
            R_ia = 0._RKIND
            m_eject = 0._RKIND
            sn_eject = 0._RKIND
            age = (t-tcp(n))*t1/3.14e13_RKIND
            if (age .lt. 0._RKIND) goto 100
            if (single_sn .eq. 1_IKIND) then
              if (age .lt. 37.53_RKIND) then
                R_ia = 0._RKIND
                if (age .lt. 10.37_RKIND
     &               .and. age .gt. 3.401_RKIND) then
                  R_ii = 0.0005408_RKIND
                endif
                if (age .gt. 10.37_RKIND) then
                         R_ii = 0.0002516_RKIND
                endif
              endif
              if (age .ge. 37.53_RKIND) then
                R_ia = 5.3e-8_RKIND * 1.6e-5_RKIND
     &                   * exp(-1.0*(age-50._RKIND)/2._RKIND)
              endif
              if (age .lt. 3.401_RKIND) then
                    R_ia = 0._RKIND
              endif
c
c    4/?  Draw from random numbers to see if SN happen or not this timestep
c
            call random_number(random)
c#ifdef FORTRAN_DEBUG
             write(0,*) "random: ", random
c#endif
            n_sn_ii = 0._RKIND
            n_sn_ia = 0._RKIND
            if (one_event .gt. 0._RKIND) then
              if (tdp(n) .gt. one_event) goto 110
              if (tdp(n) .lt. one_event
     &                .and. t .ge. tdp(n)*0.05) then
                n_sn_ii = 1._RKIND
                tdp(n) = tdp(n) + 1._RKIND
                goto 130
              endif
            endif
            P_ii = mstar * R_ii*dt*t1/3.14e13_RKIND
            if (P_ii .gt. 1._RKIND) then
              write(6,*) 'P_ii: ', P_ii
              write(6,*) 'MP: ',mp(n)*m_units, 'dt: ', dt, 'T1: ',t1
              write(6,*) 'P_ii > 1.0!!'
              write(6,*)
     &          'Need to reduce timesteps or reduce particle mass!!'
c
c       Allow a SNe or two to go off with no restrictions
c         but after that, require that p_ii < 1 s.t. only 1 sne per timestep!
c
              if (t-tcp(n)*t1/3.14e13_RKIND .gt. 3.7) then
                write(0,*) 'Too old and too high P_ii!!! Exiting!!!'
                ERROR_MESSAGE
              endif
            endif
            if (random .le. P_ii
     &                .and. mstar .gt. 10.5) then
               n_sn_ii = 1._RKIND !anint(mp(n) * R_ii * dt * t1/3.14e13_RKIND)
               !tdp(n) = tdp(n) + 1._RKIND
            else
               n_sn_ii = 0._RKIND
            endif
            if (age .ge. 37.53_RKIND) then
              call random_number(random)
              if (random .le. mstar * R_ia * dt * t1/3.14e13_RKIND) then
                n_sn_ia = 1._RKIND !anint(mp(n) * R_ia * dt * t1/3.14e13_RKIND)
              else
                n_sn_ia = 0._RKIND
              endif
            else
              n_sn_ia = 0._RKIND
            endif
            write(0,*) "p_ii = ",P_ii, "p_ia = ", P_ia
 130        if (n_sn_ia .eq. 0._RKIND
     &              .and. n_sn_ii .eq. 0._RKIND) then
c              write(6,*) 'no supernova this step'
              goto 110
            else
              write(0,*) 'SUPERNOVA!!',n, n_sn_ii, n_sn_ia,
     &          age
            endif
c
c    5/?  Calculate mass ejected, metal ejected and energy from sn
c
c
c         i.) mass in Msun of metal from type II
            snii_metals = n_sn_ii * (1.91_RKIND
     &                   + 0.0479*MAX(zcell/0.02_RKIND, 1.65_RKIND))
            sn_eject = sn_eject + n_sn_ii * 10.5_RKIND
c         ii.) mass in Msun of metals from type Ia
            snia_metals = n_sn_ia * 1.4_RKIND
            sn_eject = sn_eject + n_sn_ia * 1.4_RKIND
c         iii.) energy in supernova (simple assuming 1e51 ergs/sn)
            e_sn = 1.0e51_RKIND * (n_sn_ia + n_sn_ii) / e_units
c
c    6/? send to add_feedback subroutine with supernova feedback values
c
            sn_eject = sn_eject/m_units
            if (sn_eject .gt. mp(n)) then
              write(0,*) "sn ejecta > particle; m_ej =", sn_eject*m_units
              goto 170
            endif
            m_eject = sn_eject
            metal_ejecta = (snia_metals + snii_metals)
     &                    /m_units
            p_ej = sqrt(2._RKIND * e_sn
     &              * sn_eject)
c#ifdef FORTRAN_DEBUG
            write(0,*) 'SN ejected mass: ',sn_eject*m_units
c#endif
            call mech_add_feedback (nbor, weights,weightsFinal,xba,
     &                        u, v, w,mu_field,
     &                        d,ge,te,metal,
     &                        nx,ny,nz,ic,jc,kc,iface,
     &                        jface,kface,dxf,dyf,
     &                        dzf,dxc,dyc,dzc,imethod,
     &                        imetal, idual, sn_eject,
     &                        metal_ejecta, p_ej, e_sn,
     &                        m_deposited, e_deposited, p_deposited,
     &                        p_units,zcell, e_units,
     &                        m_units,dunits,dx, 0_IKIND,x1)
            endif
            temp = 1.998e33 * 1e5
c
c    6/?  Calculate mass loss from winds, if applicable
c
c         a.) Mass loss; msun / Gyr
c
c        write(6,*) 'calculating winds'
            m_winds=0._RKIND
            e_wind=0._RKIND
            wind_metal=0._RKIND
            p_ej=0._RKIND
 110        if (star_winds .eq. 1_IKIND .and.
     &              mstar .gt. 100._RKIND) then
              if (age < 1._RKIND) then
                    wind_factor = 4.763_RKIND
     &                    * min((0.01_RKIND + zcell/0.02_RKIND), 1.0)
     &                           * age
              endif
              if (age > 1._RKIND .and. age < 3.5_RKIND) then
                    wind_factor = 4.763_RKIND *
     &                    min((0.01_RKIND + zcell/0.02_RKIND), 1.0)
     &                            *(age)
     &                           **(1.45_RKIND + 0.08_RKIND
     &                           * min(log(zcell/0.02_RKIND), 1.0))
              endif
              if (age > 3.5_RKIND .and. age < 100_RKIND) then
                    wind_factor =
     &                  29.4 * (age / 3.5_RKIND)**(-3.25_RKIND)
     &                           + 0.0042_RKIND
              endif
              if (age > 100._RKIND) then
                    wind_factor = 0.42 * (age / 1000)**(-1.1)
     &                           / (19.81/log(age))
              endif
c
#ifdef FORTRAN_DEBUG
              write(0,*) 'wind factor: ',wind_factor
              write(0,*) 'zcell: ',zcell/0.02
#endif
                m_winds = mp(n)*m_units
     &                    * wind_factor * dt * t1 / 3.14e16_RKIND
                if (m_winds .gt. mstar) then
                  m_winds = 0.054_RKIND*mstar
                  write(6,*) 'M_winds too large'
                endif
                m_winds = m_winds/m_units
                if (m_winds .gt. mp(n)-sn_eject) then
                  write(0,*) "m_winds too large! m =",m_winds*m_units
                  m_eject = sn_eject
                  goto 170
                endif
                m_eject = m_winds +m_eject
c         b.) winds metals
                wind_metal = (0.0278_RKIND + 0.0041_RKIND
     &          * min(max(zcell/0.02_RKIND, 1.65_RKIND), 5.0)) * m_winds
#ifdef FORTRAN_DEBUG
              write(6,*) 'wind metal: ', wind_metal*m_units
#endif
c
c         c.) energy in winds
c              i.) l_kinetic
              if (age .lt. 100_RKIND) then
                  psi_k = 5.94e4_RKIND
     &                  / (1._RKIND+ age/2.5_RKIND)**(1.4_RKIND)
     &                  + (t/50._RKIND)**5._RKIND + 4.83_RKIND
              endif
              if (age .ge. 100_RKIND) then
                  psi_k = 4.83_RKIND
              endif
c              ii.) v_wind
c
c              v_wind = sqrt(2_RKIND * psi_k * 10**12_RKIND)
              e_wind = psi_k * 1e12_RKIND * m_winds * m_units
     &                /e_units
              p_ej = sqrt(2._RKIND * e_wind / m_winds)
c#ifdef FORTRAN_DEBUG
              write(0,*) 'e_winds: ', e_wind*e_units
c              write(0,*) 'winds p: ', p_ej*p_units
c              write(0,*) 'wind mass: ',m_winds * m_units
c#endif
              if (e_wind*e_units .lt. 1e10_RKIND) goto 170

              call mech_add_feedback(nbor, weights,weightsFinal,xba,
     &                        u, v, w,mu_field,
     &                        d,ge,te,metal,
     &                        nx,ny,nz,ic,jc,kc,iface,
     &                        jface,kface,dxf,dyf,
     &                        dzf,dxc,dyc,dzc,imethod,
     &                        imetal, idual, m_winds,
     &                        wind_metal, p_ej, e_wind,
     &                        m_deposited, e_deposited, p_deposited,
     &                        p_units,zcell, e_units,
     &                        m_units,dunits,dx, 1_IKIND, x1)
            endif ! star_winds == 1
c    remove mass from particle
c#ifdef FORTRAN_DEBUG
               write(0,*) 'total mass loss: ', m_eject * m_units
c#endif
 170           mp(n) = mp(n) - m_eject
            if (mp(n) .lt. 0._RKIND) then
              write(0,*) "Breaking error; negative particle mass!"
              ERROR_MESSAGE
            endif
            call mech_momentum(u,v,w,d,metal, up(n), vp(n), wp(n),
     &                  nx, ny, nz, ic, jc, kc,
     &                  iface, jface, kface,
     &                  imethod, imetal, -1_IKIND)
c
c       Error checking:
c
c#ifdef FORTRAN_DEBUG
          write(0,*) 'mp post: ', mp(n)*m_units
!          write(0,*) 'm_deposited/m_ejected', m_deposited/m_eject
          write(0,*) 'e_deposited/e_ejected: ',
     &                  e_deposited/(e_wind)
          write(0,*) '|P|: ', (p_deposited(1) + p_deposited(2)
     &                + p_deposited(3))*p_units
          write(0,*) 'Metal deposited/ejected: ',
     &          m_deposited/(metal_ejecta+wind_metal)
! #endif
          endif ! star particle calculation
 100    continue
        enddo    ! end loop over particles
 10   return
      end
c
c
c=================================================================================
c                 Adding Feedback
c=================================================================================
c
cc     Compute and deposit momentum.  This follows the
c              mechanical feedback methods present in Hopkins 2017.
c              Each neighbor cell is taken as a point of gas at cell
c              center to calculate the coupling from stellar feedback.
c              Takes in a list of "particle" positions creating a 3x3 cloud
c              along with weight vectors for each "particle".
c              Each cloud particle is then distributed to the mesh using
c              cloud-in-cell
c
c       nbor - position of neighbor cloud particles that have coupled to feedback
c       weightsFinal - array of weights determining coupling to neighbor particles
c       m_eject - mass of ejecta
c       e_sn    - energy of ejecta
c       p_ej    - total ejected momenta e_sn= p_ej^2/2 m_eject
c       d, metal, te, ge - density, metal, total energy and thermal energy fields
c       nx, ny, nz -number of entries in d, metal, te, ge
c       x1, t1, dunits - conversion of distance, time, density to physical units
c       imetal - metallicity field flag
c       mcell - mass of the feedback particle is ~mass of cell
c       mdep, edep, pdep - running sum of deposited momenta, energy and mass
      subroutine mech_add_feedback(nbor, weights, weightsFinal, xba,
     &                        pu, pv, pw, mu_field,
     &                        d, ge, te, metal, nx, ny, nz,
     &                        ic, jc, kc, iface, jface, kface,
     &                        dxf, dyf, dzf, dxc, dyc, dzc,
     &                        imethod, imetal, idual,
     &                        m_eject, metal_ejecta, p_ej, e_sn,
     &                        m_deposited, e_deposited,p_deposited,
     &                        p_units,zcell,e_units,
     &                        m_units,d_units,dx, winds, xunits)
c
      implicit none
#include "fortran_types.def"
#include "phys_const.def"
c
c     Arguments
c
      INTG_PREC nx, ny, nz, ic, jc, kc, idual, a, winds
      INTG_PREC iface, jface, kface, imethod, imetal, imulti_metals
      R_PREC    d(nx, ny, nz), metal(nx,ny,nz), ge(nx,ny,nz)
      R_PREC    pu(nx,ny,nz), pv(nx,ny,nz), pw(nx,ny,nz), te(nx,ny,nz),
     &          mu_field(nx,ny,nz)
      R_PREC    metal_ejecta, m_eject, p_ej, e_sn, delta_metal, delta_m
      R_PREC    delta_e, p_units, zcell, e_units, t1, nb, dx
      R_PREC    dxf, dyf, dzf, dxc, dyc, dzc, tempx,xunits,
     &        dxf1, dyf1, dzf1, dxc1, dyc1, dzc1
c
c     Locals
c
      INTG_PREC i, j, k, i1, j1, k1, n_sn, use_pt
      R_PREC    delta_mass, delta_pu, delta_pv, delta_pw, delta_therm,
     &          dratio, tot_mass, temp, scalar_weight, p_t,p_rat,
     &          m_deposited, e_deposited, fz,m_units, d_units, m_cell,
     &          dmean, nmean, zmean, delta_z, m_shell, v_shell, R_pds,
     &          mumean, shell_masses, e_couple, metal_shell
      R_PREC  r_cool(3,3,3)
      R_PREC  delta_p(3), p_deposited(3)
      R_PREC  weightsFinal(3,3,3,3), nbor(3,3,3,3), xba(3,3,3,3)
      R_PREC  weights(3,3,3)
      R_PREC r_factor(3,3,3), mod_xba(3,3,3)
      R_PREC fd(4,4,4), fmetal(4,4,4), fu(4,4,4), fv(4,4,4), fw(4,4,4)
c
c     Error check
c
      if (imulti_metals .eq. 1_IKIND) then
         write(6,*) "momentum: not supported"
      endif
c
c     Loop "cells" in particle-frame
c
      tot_mass = 0._RKIND
      temp = zcell / 0.02_RKIND
      if (temp .lt. 0.01_RKIND) then
          fz = 2._RKIND
      else
          fz = (zcell/0.02_RKIND)**(-0.14_RKIND)
      endif
      m_cell = d(ic, jc, kc)
      write(0,*) "mcell =", m_cell *m_units
      dmean = 0._RKIND
      mumean = 0._RKIND
      zmean = 0._RKIND
      shell_masses = 0._RKIND
      do k = -1_IKIND, 1_IKIND
        do j = -1_IKIND, 1_IKIND
          do i = -1_IKIND, 1_IKIND
            nb = d(ic+i,jc+j,kc+k)*d_units/mass_h/mu_field(ic+i,jc+j,kc+k)
            dmean = dmean + d(ic+i, jc+j, kc+k)
            r_cool (i+2, j+2, k+2) = (28.4_RKIND * nb**(-3.0/7.0)
     &                * ((e_sn*e_units)/1e51_RKIND)**(2.0/7.0)*fz)
     &                * 3.018e18_RKIND / xunits
            mod_xba(i+2,j+2,k+2) =
     &              sqrt(xba(i+2,j+2,k+2, 1)*xba(i+2,j+2,k+2,1)
     &                  + xba(i+2,j+2,k+2,2)*xba(i+2,j+2,k+2,2)
     &                  + xba(i+2,j+2,k+2,3)*xba(i+2,j+2,k+2,3))
            r_factor (i+2, j+2, k+2) =
     &              mod_xba(i+2,j+2, k+2)
     $                    / r_cool(i+2,j+2,k+2)
            mumean = mumean + mu_field(ic+i, jc+j, kc+k)
            zmean = zmean + metal(ic+i, jc+j, kc+k)
          enddo
        enddo
      enddo
      if (minval(r_cool) .lt. maxval(mod_xba)) use_pt = 1_IKIND
      if (minval(r_cool) .gt. maxval(mod_xba)) use_pt = 0_IKIND
      dmean = dmean / 27._RKIND
      mumean = mumean / 27._RKIND
      zmean = zmean / 27._RKIND
      nmean = dmean*d_units / mass_h / mumean
c
c     make and set faux-deposition arrays.  These will be deposited onto the real grid later.
c
      do k = 1_IKIND,4_IKIND
        do j = 1_IKIND,4_IKIND
          do i = 1_IKIND,4_IKIND
            fd(i,j,k) = 0._RKIND
            fmetal(i,j,k) = 0._RKIND
            fu(i,j,k) = 0._RKIND
            fv(i,j,k) = 0._RKIND
            fw(i,j,k) = 0._RKIND
          enddo
        enddo
      enddo
      if (use_pt .eq. 1_IKIND) then
        write(0,*) "energy reduction: r_factor = ",(maxval(r_factor))**(-6.5_RKIND)
        write(0,*) "for r_cool = ",minval(r_cool)*xunits/(3.018e18)
        write(0,*) "and x_ba = ",maxval(mod_xba)*xunits/(3.018e18)
        if (maxval(r_factor)**(-6.5_RKIND) .lt. 1e-40_RKIND) then
          e_couple = 0.0
        else
          e_couple = e_sn * (maxval(r_factor))**(-6.5_RKIND)
        endif
        write(0,*) "new coupling energy =", e_couple *e_units
      endif
      p_t = (4.8e5_RKIND*1.0/nmean**(1._RKIND/7._RKIND)
     &            *  (e_couple*e_units/1e51_RKIND)**(13._RKIND/14._RKIND)
     &            * fz)
     &            / p_units
c
c     If using p_t, need to account for the fact that the
c       mass of the shell is significantly greater than just
c       the supernova ejecta.
c      This portion of modification will only apply to
c         supernovae, and not stellar winds.
c      This calculation is taken from Cioffi 1988
c       where we take the radius of the shell to be the
c       coupling particle radius mod_xba
c
      m_shell = m_eject
      metal_shell = metal_ejecta
      if(use_pt .eq. 1_IKIND .and. winds .eq. 0) then
        write(0,*) "shifting shell mass using: e_sn=",e_couple*e_units,
     &              "nmean = ",nmean, "zmean =", zmean
        R_pds = 14._RKIND * (e_couple * e_units/1e51_RKIND)**(2._RKIND/7._RKIND)
     &                    / (nmean)**(3._RKIND/7._RKIND)
     &                    / (zmean/0.02_RKIND)**(1._RKIND/7._RKIND)
     &                    * 3.018e18_RKIND /xunits
        ! [R_pds] = cm
        write(0,*) "R_pds = ",R_pds*xunits/3.018e18
        v_shell = 413 * nmean**(1._RKIND/7._RKIND)
     &                      * (zmean/0.02)**(3._RKIND/14._RKIND)
     &                     * (e_sn*e_units/1.e51_RKIND)**(1._RKIND/14._RKIND)
     &                      * (maxval(mod_xba)/R_pds)**(-7._RKIND/3._RKIND)
        write(0,*) "v_shell = ",v_shell
        ! [v_shell] = km/s
        m_shell = (exp(-(maxval(mod_xba) - maxval(r_cool))/R_pds)
     &                    * p_t * p_units/v_shell)/m_units
     &                    + m_eject ![m_shell] = codemass
        write(0,*) "max shell mass: ", p_t * p_units/v_shell
        metal_shell = zcell * (m_shell-m_eject) + metal_ejecta 
        write(0,*) "new shell mass: ",m_shell * m_units
        write(0,*) "zcell = ",zcell
      endif


      do k = -1_IKIND, +1_IKIND
         do j = -1_IKIND, +1_IKIND
            do i = -1_IKIND, +1_IKIND
c
c     calculate mass, energy, momentum, etc for this cell particle
c
            scalar_weight= weights(i+2, j+2, k+2)
            delta_m = m_shell*scalar_weight
c
c     if r_ptcl > R_cool, need to reduce energy to account for pdV work done
c       in energy conserving phase
c
            delta_e = e_couple * scalar_weight
c            if (delta_e .lt. 0_RKIND)
c            write(6,*) 'delta_e: ',delta_e*e_units
            delta_metal = metal_shell * scalar_weight
              do a = 1_IKIND, 3_IKIND
                temp = sqrt(1._RKIND+m_cell/delta_m)
c#ifdef FORTRAN_DEBUG
c                write(6,*) 'temp, p_t/p_ej ',temp, p_t/p_ej
c#endif
c
c       While Hopkins uses the min(sqrt(1+ma/m_ej), pt/p_ej), since we have the cooling radius
c         readily available and the particles distance is easy, we can decide if we
c         resolve the cooling radius explicitly
c
c
                if (use_pt .eq. 0) then
                  delta_p(a) = p_ej*temp
     &                        *weightsFinal(i+2,j+2,k+2,a)
                  if (delta_m .eq. 0) then
                    delta_p(a) = 0._RKIND
                  endif
                endif
                if (use_pt .eq. 1_IKIND)
     &           delta_p(a) = p_t
     &                        *weightsFinal(i+2,j+2,k+2,a)
                        
 120              continue
              enddo

c 
c     For each particle "cell", do CIC-like deposit
c     compute zone and face centered weight factors
c
                do i1 = i, i+1_IKIND
                  dxf1 = dxf
                  dxc1 = dxc
                  if (i1 .eq. i+1_IKIND) dxf1 = 1._RKIND - dxf
                  if (i1 .eq. i+1_IKIND) dxc1 = 1._RKIND - dxc
                  do j1 = j, j+1_IKIND
                     dyf1 = dyf
                     dyc1 = dyc
                     if (j1 .eq. j+1_IKIND) dyf1 = 1._RKIND - dyf
                     if (j1 .eq. j+1_IKIND) dyc1 = 1._RKIND - dyc
                     do k1 = k, k+1_IKIND
                        dzf1 = dzf
                        dzc1 = dzc
                        if (k1 .eq. k+1_IKIND) dzf1 = 1._RKIND - dzf
                        if (k1 .eq. k+1_IKIND) dzc1 = 1._RKIND - dzc
                        delta_mass =   delta_m*dxc1*dyc1*dzc1
                        delta_z = delta_metal*dxc1*dyc1*dzc1
                        delta_pu   =  delta_p(1)*dxf1*dyc1*dzc1
                        delta_pv   =  delta_p(2)*dxc1*dyf1*dzc1
                        delta_pw   =  delta_p(3)*dxc1*dyc1*dzf1
                        delta_therm = e_couple*dxc1*dyc1*dzc1
c            write(6,*) "to deposit: ", delta_therm*e_units
c
c     Add mass, momentum
c     (add thermal energy here)
c
                        dratio = d(ic+i1, jc+j1, kc+k1)/
     &                       (d(ic+i1, jc+j1, kc+k1) + delta_mass)
                        fd(i1+2 ,j1+2 ,k1+2) = fd(i1+2 ,j1+2 ,k1+2)
     &                       + delta_mass
                        fu(i1+2 ,j1+2 ,k1+2) =
     &                       fu(i1+2 ,j1+2 ,k1+2) + delta_pu
                        fv(i1+2 ,j1+2 ,k1+2) =
     &                       fv(i1+2 ,j1+2 ,k1+2) + delta_pv
                        fw(i1+2 ,j1+2 ,k1+2) =
     &                       fw(i1+2 ,j1+2 ,k1+2) + delta_pw
c
                        tot_mass = tot_mass + delta_mass

                        p_deposited(1) = delta_pu + p_deposited(1)
                        p_deposited(2) = delta_pv + p_deposited(2)
                        p_deposited(3) = delta_pw + p_deposited(3)
c
c     Add increase in kinetic energy to the total energy field
c
                      temp = (delta_pu**2 + delta_pv**2 + delta_pw**2)
     &                        / (2._RKIND*delta_mass)
c#ifdef FORTRAN_DEBUG
c                      write(6,*) 'Dtherm added: ',delta_therm*e_units
c#endif
                      if ((delta_therm*e_units) .gt. 1e53_RKIND .or.
     &                  (temp*e_units) .gt. 1.0e53_RKIND) then
                        write(6,*) "Dtherm explosion: dt: ",delta_therm*e_units,
     &                    'ke: ',temp*e_units,'mass dep: ',delta_mass*m_units
                      endif
          ! Add kinetic and thermal energy to total energy
c#ifdef FORTRAN_DEBUG
c            write(6,*) 'e_cell, KE, dtherm',te(ic+i1 ,jc+j1 ,kc+k1),
c     &                       temp,
c     &                       delta_therm
c#endif

c     Adding increase in kinetic energy to the total energy field
c     Metal feedback (note that in this function gas metal is
c     a fraction (rho_metal/rho_gas) rather than a density.
c     The conversion has been done in the handling routine)
c
                        if (imetal .eq. 1_IKIND) then
                           fmetal(i1+2 ,j1+2 ,k1+2) =
     &                          fmetal(i1+2 ,j1+2 ,k1+2)
     &                          + delta_z
                           m_deposited = m_deposited +
     &                              delta_z/d(ic+i1,jc+j1,kc+k1)

                        endif
c
c     End loop over CIC-deposit
c
                     enddo
                  enddo
               enddo
c
c     Coupled kinetic energy is only a fraction of total energy.
c       could ignore this thermal energy, or deposit it and 
c       let it evolve by the hydro (just radiate away in general)
c     Since the ionization state (self-shielding, etc) can be affected by
c       temperature, I think it's a good idea to include this term
c       At worst, low resolution will approach a cen & ostriker thermal 
c       feedback model.
c
               if (e_couple .lt. e_sn 
     &                    .and. i .eq. 0 
     &                    .and. j .eq. 0 
     &                    .and. k .eq. 0) then
                      te(ic,jc ,kc) =
     &                       te(ic ,jc ,kc)*dratio
     &                       + (e_sn-e_couple)/d(ic, jc, kc)
c
                      if (idual .eq. 1_IKIND)
     &                    ge(ic,jc ,kc) =
     &                       ge(ic, jc, kc)*dratio +
     &                       (e_sn-e_couple) / d(ic, jc, kc)
                      e_deposited = e_deposited
     &                                + (e_sn-e_couple)
                endif
c 
c     End loop over "cells" in particle-frame
c
            enddo
         enddo
      enddo
c
c     Now, deposit those fake fields onto the real grid
c
      do k = 1_IKIND,4_IKIND
        do j = 1_IKIND,4_IKIND
          do i = 1_IKIND,4_IKIND
            d(ic-2+i, jc-2+j, kc-2+k) = d(ic-2+i, jc-2+j, kc-2+k)
     &                                  + fd(i,j,k)
            metal(ic-2+i, jc-2+j, kc-2+k) = metal(ic-2+i, jc-2+j, kc-2+k)
     &                                      + fmetal(i,j,k)
     &                                      / d(ic-2+i, jc-2+j, kc-2+k)
            pu(ic-2+i, jc-2+j, kc-2+k) = pu(ic-2+i, jc-2+j, kc-2+k)
     &                                   + fu(i,j,k)
            pv(ic-2+i, jc-2+j, kc-2+k) = pv(ic-2+i, jc-2+j, kc-2+k)
     &                                   + fv(i,j,k)
            pw(ic-2+i, jc-2+j, kc-2+k) = pw(ic-2+i, jc-2+j, kc-2+k)
     &                                   + fw(i,j,k)
          enddo
        enddo
      enddo
c#ifdef FORTRAN_DEBUG
      write(0,*) "deposited quantities:"
      write(0,*) "mass = ",sum(fd)*m_units
      write(0,*) "metal = ",sum(fmetal)*m_units
      write(0,*) "p_x = ", sum(fu)*p_units
      write(0,*) "p_y = ", sum(fv)*p_units
      write(0,*) "p_z = ", sum(fw)*p_units
c#endif
      ! Taking mass out of feedback cell from SN shell
      if (winds .eq. 0_IKIND .and. shell_masses .gt. 0._RKIND) then
        write(0,*) "Ejected shell mass = ",shell_masses * m_units
        write(0,*) "cell mass pre = ", d(ic,jc,kc)*m_units
        d(ic,jc,kc) = d(ic,jc,kc) - shell_masses
        write(0,*) "cell mass post =", d(ic,jc,kc)*m_units
      endif
c
c
 1100   return
        end
c ==============================================================================
c
c ==============================================================================
c
c ==========================================================
c
c     Convert velocities to momentum and back
c
      subroutine mech_momentum(u, v, w, d, metal, up, vp, wp,
     &                    nx, ny, nz, ic, jc, kc,
     &                    iface, jface, kface, imethod, imetal, idir)
c
      implicit none
#include "fortran_types.def"
c
c     Arguments
c
      INTG_PREC nx, ny, nz, ic, jc, kc
      INTG_PREC iface, jface, kface, imethod, imetal, idir
      R_PREC    d(nx, ny, nz), metal(nx,ny,nz)
      R_PREC    u(nx,ny,nz), v(nx,ny,nz), w(nx,ny,nz)
      R_PREC    up, vp, wp
c
c     Locals
c
      INTG_PREC i, j, k
c
c     Error check
c
      if (idir .ne. -1_IKIND .and. idir .ne. 1_IKIND) then
        write(6,*) 'incorrect idir value in momentum call'
      endif
c
c     Loop over velocities, multiplying by densities (or dividing if
c       converting back)
c
      do k = -1_IKIND, +2_IKIND
        do j = -1_IKIND, +2_IKIND
          do i = -1_IKIND, +2_IKIND
c
c              idir = +1: convert vel -> mom
c
            if (idir. eq. +1_IKIND) then
               if (imethod .eq. 2_IKIND) then
                  u(iface+i ,jc+j ,kc+k) =
     &                    (u(iface+i ,jc+j ,kc+k) - up)
     &                    * 0.5_RKIND * (d(iface+i  , jc+j, kc+k) +
     &                    d(iface+i+1_IKIND, jc+j, kc+k))
                  v(ic+i ,jface+j ,kc+k) =
     &                    (v(ic+i ,jface+j ,kc+k) - vp)
     &                    * 0.5_RKIND * (d(ic+i, jface+j  , kc+k) +
     &                    d(ic+i, jface+j+1_IKIND, kc+k))
                  w(ic+i ,jc+j ,kface+k) =
     &                    (w(ic+i ,jc+j ,kface+k) - wp)
     &                    * 0.5_RKIND * (d(ic+i, jc+j, kface+k  ) +
     &                    d(ic+i, jc+j, kface+k+1_IKIND))
               else
                  u(ic+i ,jc+j ,kc+k) = (u(ic+i ,jc+j ,kc+k)-up) *
     &                                      d(ic+i, jc+j, kc+k)
                  v(ic+i ,jc+j ,kc+k) = (v(ic+i ,jc+j ,kc+k)-vp) *
     &                                      d(ic+i, jc+j, kc+k)
                  w(ic+i ,jc+j ,kc+k) = (w(ic+i ,jc+j ,kc+k)-wp) *
     &                                      d(ic+i, jc+j, kc+k)
               endif
               if (imetal .eq. 1_IKIND) then
                  metal(ic+i,jc+j,kc+k) = metal(ic+i,jc+j,kc+k) *
     &                    d(ic+i,jc+j,kc+k)
               endif
c
c              if idir = -1: convert mom -> vel
c
            else
               if (imethod .eq. 2_IKIND) then
                  u(iface+i ,jc+j ,kc+k) = u(iface+i ,jc+j ,kc+k)
     &                    /( 0.5_RKIND * (d(iface+i  , jc+j, kc+k) +
     &                             d(iface+i+1_IKIND, jc+j, kc+k))) + up
                  v(ic+i ,jface+j ,kc+k) = v(ic+i ,jface+j ,kc+k)
     &                    /( 0.5_RKIND * (d(ic+i, jface+j  , kc+k) +
     &                             d(ic+i, jface+j+1_IKIND, kc+k))) + vp
                  w(ic+i ,jc+j ,kface+k) = w(ic+i ,jc+j ,kface+k)
     &                    /( 0.5_RKIND * (d(ic+i, jc+j, kface+k  ) +
     &                             d(ic+i, jc+j, kface+k+1_IKIND))) + wp
               else
                  u(ic+i ,jc+j ,kc+k) = u(ic+i ,jc+j ,kc+k) /
     &                                     d(ic+i, jc+j, kc+k) + up
                  v(ic+i ,jc+j ,kc+k) = v(ic+i ,jc+j ,kc+k) /
     &                                     d(ic+i, jc+j, kc+k) + vp
                  w(ic+i ,jc+j ,kc+k) = w(ic+i ,jc+j ,kc+k) /
     &                                     d(ic+i, jc+j, kc+k) + wp
               endif
               if (imetal .eq. 1_IKIND) then
                  metal(ic+i,jc+j,kc+k) = metal(ic+i,jc+j,kc+k) /
     &                    d(ic+i,jc+j,kc+k)
               endif
            endif
c
         enddo
      enddo
      enddo
c
      return
      end
